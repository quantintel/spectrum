<?xml version="1.0" encoding="utf-8"?>
<html>
<head>
    <title>Scala tutorial for programmers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="keywords" content="Scala Java tutorial JVM reference" />
    <meta name="Description" content="Scala tutorial - the comprehension guide to Scala language for programmers" />



    <link href="../_static/book2.css" type="text/css" rel="stylesheet" />
    <link href="../_static/tocbar.css" type="text/css" rel="stylesheet" />

    <script src="../_static/zepto.min.js"  type="text/javascript" ></script>
    <script src="../_static/tocbar.js" type="text/javascript" ></script>
    <script src="../_static/toc.js" type="text/javascript" ></script>
    <script type="text/javascript" >
        $(document).ready(function(i) {
            add_toc_entry("h1, h2", false);
        })
    </script>

    <!-- prebuilded packages at http://api.yandex.ru/jslibs/libs.xml#highlightjs -->
    <link href="../_static/highlight/styles/school_book.css " type="text/css" rel="stylesheet" />
    <script src="../_static/highlight/highlight.pack_scala.js" type="text/javascript" ></script>
    <!-- line highlight for highlightjs:	http://mrer.org.ua/?article=show[be_careful_guru][highlight_js_with_row_numbers][en]		-->

</head>

<body>

<div id="tocbar-wrapper">
    <div id="tocbar">
        <div id="toc_button">Table of Contents</div>
        Main page: <a href="../index.html">Robert Zaremba - Scale it blog</a> | Scala tutorial for programmers
    </div>
    <div id="toc">
        <!-- <div>
      <a href="index.html"  class="h1">HOME</a>
      <a href="contact.html" class="h1">Contact</a>
      <br />
      <p class="h1">Programming stuff</p>
      <a href="emacs_cheatsheet.html" class="h2">emacs cheatsheet</a>
      <a href="vim_cheatsheet.html" class="h2">vim cheatsheet</a>
      <a href="scala.html" class="h2">Scala. The tutorial</a>
    </div> -->
    </div>
</div>


<div class="main_title">Scala<div class="subtitle">tutorial for programmers</div></div>
<br />
<br />


<hr />
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0; margin: 5px 10px" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Scala tutorial for programmers</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://rz.scale-it.pl" property="cc:attributionName" rel="cc:attributionURL">Robert Zaremba</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="http://rz.scale-it.pl/docs/scala.html" rel="dct:source">http://rz.scale-it.pl/docs/scala.html</a>.
<hr />
<p>Version: 1.0, <span class="space" >2012</span></p>
<p>If you want to redistribute this work, please share this information with me, so I can link it too</p>


<br />
<br />
<div id="make-toc-here"></div>


<h1>Intro</h1>
<div>
    The mixture of OOP &amp;  FP ( functional programming) and its concurrent features makes Scala an excellent bread earning language of the future. Since Scala provides concurrency in terms of "ACTORS" (yep, inherited from ERLANG)  and with web development frameworks like LIFT, SCALATRA, PLAY it can be termed as a replacement of Java on the JVM in the coming years. Like Groovy you can use all existing java libraries, however the learning curve is little steep because of the complexity of the language. But as per my observation and as per the blogosphere world this language can fit extremely well in the Java world.
    <p>
        Even as per a blog the Groovy developer says "if he knows that Scala exists and is about to come then he would never had developed Groovy". This statement itself says a lot about Scala.
    </p>

    <p>Scala is a powerful language. And the power can makes problems to people who don't know Scala enough. Here comes this tutorial - to make Scala more friendly for programmers as well as present Scala in a compact way.
    </p>
</div>



<h1>JVM and Scala binary options.</h1>
<div>
    <ul>
        <li><code>javap</code> - disassembles the class file. Prints the content of the classes and packages (values, fields, functions of the class)</li>
        <li><code>scalap</code> - similar to javap</li>
        <li><code>-optimise</code> Generates faster bytecode by applying optimisations to the program</li>
        <li><code>-unchecked</code> option to scala or scalac: Enable detailed unchecked (erasure) warnings. Useful for testing / debuging.</li>
    </ul>


</div>

<h1>Syntax</h1>
<div>
    <a href="http://jim-mcbeath.blogspot.com/2008/09/scala-syntax-primer.html">Scala Syntax Primer</a> post by Jim McBeath.

    <h2>Blocks</h2>
    <div>
        We can build block in two ways:
		  <pre><code class="scala">
              ( expression 1;
              expression 2;
              expression 3;
              )

              // Second way:
              { expression 1    // don't need to use a ';'
              expression 2
              expression 3
              }
          </code></pre>

        For method call with exactly one argument you can use curly braces to surround the argument instead of parentheses.
        <p>The purpose of this ability to substitute curly braces for parentheses for passing in one argument is to enable client programmers to write function literals between curly braces. This can make a method call feel more like a control abstraction.
        </p>


    </div>


    <h2>Identifiers</h2>
    <div>
        Scala has two namespaces for identifiers: <em>value</em> scope and <em>type</em> scope. So this is possible to define to identifiers with the same name (one as a class, other as a val) and use them in the same block. However compiler expects that the identifier from <em>value</em> scope will be the companion object to appropriate identifier from <em>type</em> scope, if not it will make a warning:
		  <pre ><code class="scala">
              class X
              val X = 1
              new X              // returns new object
              X                  // returns 1
          </code></pre>
        Identifier kind:
        <ul>
            <li>alphanumeric identifier: <em>[a-zA-Z][a-zA-Z0-9_]*</em></li>
            <li>operator identifier: <em>printable ASCII - {"",(,), {,}, '}</em></li>
            <li>mixed identifier: <em>[A-z]&lt;operator_identifier&gt;</em></li>
            <li>literal - arbitrary string enclosed in back tick (`...`). Can contain reserved word. Eg: <em>X.`yield`</em></li>
        </ul>
        A higher kind type with two type qualifiers, such as Pair[String,Int], can be written in infix
		  <pre><code class="scala">
              var x : String Pair Int = (1, "aa")      <i>// var x: Pair[String, Int] = ...</i>
              type X = M1 + M2                         <i>// for some type M1, M2, +[T, T2]</i>
              type +[A,B] = Pair[A,B]
              Quantity[M + M2]                         <i>// goes to Quantity[+[M, M2]]</i>
              head :: tail                             <i>// apply method in class ::[T](head: T, tail: List[T])</i>
          </code></pre>

        <h3 class="none"></h3>
        <h4>Operators</h4>
        <div>
            Scala has great support for infix / prefix /postfix operators.<br />
            There is a great <a href="http://jim-mcbeath.blogspot.com/2008/11/scala-type-infix-operators.html">post</a> about them, which I don't want to repeat.
            More about operators in subsection <a href="#methods_operators">method - operators</a>
        </div>

        <h4>Methods</h4>
        <div>
            <p>When operator name ends with ":" then the operator is bind to right argument and left side is applied as an argument.</p>
            <p>Default methods arguments have modifier <em>val</em></p>
            <p><em>return</em> keyword is not required</p>
            <p>The method return type, which don't return a value, is <code>Unit</code>. To make the method returning to return Unit:</p>
            <ul>
                <li>Set return type to <code>Unit</code></li>
                <li>omit '=' sing after method head, eg: <code>def f(){...}</code></li>
            </ul>
        </div>

    </div>
</div>




<h1>Types</h1>
<div>
    <h2 >Base types</h2>
    <div>
        <h3 class="none" ></h3>
        <h4>Char</h4>
        <div>
            16-bit unicode
        </div>

        <h4>Long</h4>
        <div>
            Literal ends with 'l' or 'L'. Example and properties:
			<pre><code class="scala">
                0xcafebabe &lt; 0
                0xcafebabeL &gt; 0
            </code></pre>
        </div>

        <h4>Double</h4>
        <div>
            Default type for floating-point variables
        </div>

        <h4>Float</h4>
        <div>
            Literal ends with 'f' or 'F'. Example and properties:
        </div>

        <h4>raw Strings</h4>
        <div>
            Strings, which preserves all char between &quot;&quot;&quot;, eg:  np: <code>"""Hi "Robert", what's up?"""</code>
            <br /><code>stripMargin="|"</code> - line from left, below """" assign margin, for which whitespaces will be displayed.
        </div>

        <h4>Constants</h4>
        <div>
            <code>final val x=5</code>
        </div>

        <h4>scala.Symbol</h4>
        <div>
            Allows to use keywords for variable names.<br />
            syntax: `&lt;alpha_num&gt;* <br />
            eg: 'variable, 'yield, Symbol("symbol_name")
        </div>

        <h4>type</h4>
        <div>
            keyword <em>type</em> defines an alias to some other type:
			<pre><code class="scala">
                type Action = () => Unit
            </code></pre>
            Action is an alias to the function type ()=>Unit
        </div>

        <h4>Null, Unit etc..</h4>
        <div>
            Scala has null value, but it's strongly recommend to <b>not use null values</b>.
            We have several null like values:
            <dl>
                <dt>Null</dt>
                <dd> - a trait</dd>

                <dt>null</dt>
                <dd>the only one instance of Null trait (tratis are abstract!)</dd>

                <dt>Nothing</dt>
                <dd>a Trait. Its a subtype of everything. But not super class of anything. There are no instances of Nothing besides Exceptions.</dd>

                <dt>None</dt>
                <dd>Option[_] concrete subclass. Used to represent a sensible return value. Just to avoid null pointer exception. Option has exactly 2 subclasses- Some and None. None indicate a missing value for an object. Option is a Monad like type, so it support safety taking elements</dd>

                <dt>Unit</dt>
                <dd>method return type which doesn't return any value</dd>
            </dl>
				<pre><code class="scala">
                    Scala.Any
                    /              \
                    /                \
                    AnyVal                  AnyRef
                    / |    | \               /  |   \
                    /  |    |  \             /   |    String
                    /   |    |   Unit        Seq  |
                    Double  |    Boolean            \ |
                    Int                      List
                    ...                        ...
                    | /  /
                    ...
                    \    \   |  |         /
                    \  \  |  |      Null
                    \ \          /
                    Nothing

                    AnyRef == Object in Java.
                </code></pre>

            Scala is a functional, so every function should return something, if not it returns Unit. This aims to difference between <code>null</code> and <code>()</code> - so that the function returns something (Unit) which is not connected to null reference.<br />
            Furthermore every object, if exists, should have a value. This indicates usability of None (None is an object with a concrete value).<br />
            Using <code>Option</code> has a lot of advantages over <code>null</code>
            <ul>
                <li>A <code>None</code> value unambiguously means the optional value is missing. A <code>null</code> value may mean a missing value or it may mean the variable was not initialized.</li>
                <li>The fact that Option contains explicit methods to get (such as <code>isEmpty, isDefined, get, getOrElse, map, filter</code>) the actual value makes you think about the possibility that it might not be there and how to handle that situation, so you are less likely to write code that mistakenly assumes there is a value when there is not.</li>
                <li>If your code assumes that there is a value and it is executed when there is not a value, then a <code>NoSuchElementException</code> exception is raised when Option is used. It is more specific than a <code>NullPointerException</code> and so should be easier to interpret, track down, and fix.</li>
            </ul>
            Example of Option usage with chaining Monad methods:
				<pre><code class="scala">
                    def getSystemProperty(s: String): Option[String] = ...
                    def loadPropertyFile(s: String): Option[String] = ...
                    val x = (getSystemProperty("PROPFILE") flatMap loadPropertyFile      <i>// Very nice implementation without boilerplate null checking</i>
                    x flatMap (_.get("TIMEOUT")) map (_.toInt) getOrElse 60)             <i>// using monad methods chaining</i>
                </code></pre>
            <h5>Legacy Java code</h5>
            <div>
                Java methods returns null frequently. Java doesn't have Option type with so elegant monads method, because Java does not have function literals.<br />
                Some approach to manage Java methods is to write wrapper functions in Scala that call the Java functions and translate between null values and None values.
            </div>
            More about why null is bad: <a href="http://stackoverflow.com/questions/1274792/is-returning-null-bad-design">http://stackoverflow.com/questions/1274792/is-returning-null-bad-design</a>.
        </div>
    </div>

    <h2>Rich Types</h2>
    <div>
        Rich types are wrapper to normal types with useful operators and methods.<br />
        There are implicit conversions from standard types (from java) to rich types (scala) through <code>implicit functions</code>.
        <ul>
            <li>Byte -> scala.runtime.RichByte</li>
            <li>Int -> scala.runtime.RichInt</li>
            <li>...</li>
            <li>String -> scala.collection.immutable.StringOps</li>
        </ul>
    </div>

</div>

<h1>Conditional expressions</h1>
<div>
    <h2 class="none" ></h2><h3 class="none" ></h3>
    <h5>if</h5>
    <div>
			<pre><code class="scala">
                if (e1) e2 [else e3]

                <i>// if else part is empty then it evaluates to</i>
                if (e1) e2 else ()
            </code></pre>
    </div>

    <h5>while</h5>
    <div>
			<pre><code class="scala">
                while (e1) e2
            </code></pre>
    </div>
    <h5>do-while</h5>
    <div>
			<pre><code class="scala">
                do e1 [';'] while (e2)
            </code></pre>
    </div>
    <h5>for loop</h5>
    <div>
        For loop is discussed <a href="#for_expression" >here</a>
    </div>


    <h2>Break, continue</h2>
    <div>
        There are now break and continue language support. However there is library support for break in <code>scala.util.control.Breaks</code>. <br />
        More in Programming in Scala e2 page 177
    </div>


    <hr />
    <a href="http://docs.scala-lang.org/sips/pending/uncluttering-control.html" >There is</a> proposal to some syntax change for control statement which is going to be more clear with less parentheses.
</div>




<h1>Classes</h1>
<div>
<p>Methods from class and it's companion object has access to <em>private</em> fields</p>

<h2 id="methods_operators">Operators</h2>
<div>
    Thanks to quiet comfortable access to method object (don't need to put '.') and set of allowed characters, operators are just class methods.<br />
    Good explanation about constructing operators, using them, and precedence can be found in <em>Scala ref 6.12.3</em>.
    <h3>unary prefix operators</h3>
    <div>
        syntax: <em>unary_&lt;char&gt;</em>, where <em>char</em> is in {+,-,!,~}.
              <pre><code class="scala">
                  class X(a: Int){
                  def unary_* = a*
                  def unary_- = a-1
                  }
                  var x = new X(2)
                  -x         // OK
                  *x         // Error, * not available as unary operator
                  x.unary_*  // ok, method call </code></pre>
    </div>

    <h3>unary postfix operators</h3>
    <div>
        Nothing special: methods without arguments and parentheses
    </div>

    <h3>Equity</h3>
    <div>
        The method <code>==</code> is predefined for any object as an alias to <code>equals</code>. If we want to overwrite <code>==</code>, we should do it by overwriting <code>equals</code> method.<br />
        The <code>==</code> is not type aware since it is inherited from <code>Any</code> class, which <code>equals</code> head is <code>equals(a:Any)</code>. So <code>==</code> takes argument of any type, and there is no compilation error when comparing not connected class, eg <code>Fish("dolphin") == Office("desk")</code>. The result will always be false. The there is only one help from compile - it will warn you when you use such comparison.
        <p>To escape from this behavior you can use <code>===</code> method from Scalaz library, which is discussed in Tools and libraries section.</p>
        The exception for <code>==</code> behavior are <em>case classes</em>, for which <code>MyCase(pa1, pa2...) == MyCase(pb1, pb2...)</code> corresponds to <code>pa1 == pb1 and pa2==pb2 ...</code>
        <h4>reference equity</h4>
        <div>
            Functions below compare memory address, which we can't overwrite.
            <ul>
                <li><code>eq</code></li>
                <li><code>ne</code></li>
            </ul>
        </div>
    </div>
</div><!-- operators -->


<h2>Constructors</h2>
<div>
    Scala has only one constructor - <em>primary constructor</em>. But we can use helper methods in form of:
    <ul>
        <li><em>auxiliary constructor</em></li>
        <li><em>apply method on companion Object</em> - it is helpful when we want to construct object in different way (for example an Array class is constructed by the size and type parameter, but we can use apply method on companion Object to specify the content of an Array without size and type).</li>
    </ul>
    <p>When we think about implementation of constructor and apply method of companion object, we need to remember that <em>apply method companion object</em> <b>doesn't take part in inheritance and polymorphism</b></p>

    <h3>Primary constructor</h3>
    <div>
        The primary constructor is the body of a "free" code in class definition.<br />
        Each variable declared in primary constructor becomes the object field<br />
        <b>Arguments of <em>primary constructor</em></b> are parameters of the class - the variables after parentheses of class name. The default scope modifier for them is <em>private[this] val</em> which will be discussed in <a href="#scope_of_protection">protection scope paragraph</a>. That means that by default we can't change the value of primary constructor arguments. We can do it by specifying whole declaration of them (eg: <code>class X(var x: Int)</code>). <br />
        If we don't specify the modifier of <em>primary constructor</em> arguments, and we will use them only in primary constructor body (not in class methods), then compiler won't add them as object fields.
        Otherwise they will become object values.

	<pre ><code>
        class A (arg: Int){
        def f(a: A) = {
        println(arg)           // OK,  arg will be stored as a object member
        println(a.arg)         // Error, arg is private[this]
        }
        }
    </code></pre>
    </div>

    <h3>Auxiliary constructor</h3>
    <div>
        It is a method which name is <em>this</em><br />
        The <em>auxiliary constructor</em> must ends with call to other constructor (at the end it must be primary constructor).
    </div>

    <h3>Private constructor</h3>
    <div>
        We add <em>private</em> keyword in front of constructor definition.<br />
        If it is a <em>primary constructor</em> then we add <em>private</em> modifier in front of the class parameter list.
        <code>class X private(...)...</code> <br />
        Private constructor is accessible only form other object methods (other constructor, methods or companion object methods)
    </div>


    <h4>Example</h4>
    <div>
	  <pre><code class="scala">
          class A (arg: Int, private[this] var xt: Int){
          //body of primary constructor is here:
          xt = some_function()         // xt is temporary value, doesn't occupy any memory
          var x1 = 1                   // mutable variable
          private var x2 = 2
          private[this] val x3 = 3     // private constant - used only by this object, not accessible from outside!
          val (x4, x5) = compute(arg)  // in this case, compiler will create hidden object field for tuple.
          val x6 = {                   // initialization using block code. All variables from block code are temporary
          val t = 3
          arg*t - xt*t
          }

          def this(arg: Int) = this(arg, 0)  // auxiliary constructor, calls primary constructor
          }


          object A {
          def apply(arg: Int) = new A (arg, 1)
          }
      </code></pre>

    </div>

    <h4>Forcing type in auxiliary constructor</h4>
    <div>
        Consider the example:
		<pre><code class="scala">
            abstract class Expectation[T] extends BooleanStatement {
            val expected: Seq[T]
            …
            }

            object Expectation {
            def apply[T](expd:     T ): Expectation[T] = new Expectation[T] {val expected = List(expd)}
            def apply[T](expd: Seq[T]): Expectation[T] = new Expectation[T] {val expected =      expd }

            }
        </code></pre>
        Here we explicitly define each <code>apply</code> to return <code>Expectation[T]</code>, else it would return a <a href="#structural_types">structural subtype</a> <code>Expectation[T]{val expected: List[T]}</code>.
    </div>
</div>

<h2>Class initialization</h2>
<div>
    We simply initialize a class using <b>new</b> keyword:
    <code> new ClassName (constructor args...)</code>.
    Furthermore we can use helper methods from <em>companion object</em> which can perform initialization for us.

    <h4>Initializing inner classes</h4>
    <div>
        There is special case about inner classes which is discussed in <a href="instantiating_inner_classes">path-dependent types - Instantiating inner classes</a>.
        <p>In general you can't instantiate an inner class without specifying an outer class instance.</p>
    </div>
</div>

<h2>Properties - getter and setter methods</h2>
<div>
    To control variable reads and writes Scala has built in mechanism.<br />
    For every field declared as <em>var</em> or <em>val</em> Scala implicitly creates getter and setter functions for it (unless you explicitly make them) and changes the meaning of field. It goes as follows:
	  <pre><code class="scala">
          class X {
          var celsius = 1
          val v = _

          def fahrenheit = celsius * 9 / 5 + 32  <i>// getter without associated field</i>
          def fahrenheit_= (f: Float) {          <i>// setter without associated field</i>
          celsius = (f - 32) * 5 / 9
          }
          }
          <i>// goes to </i>
          class X{
          private[this] var celsius = 1
          private[this] val v2 = 0

          def celsius: Int = v1           <i>// default getter </i>
          def celsius_(x: Int) = v2=x     <i>// default setter </i>

          def v2: Int = v2                <i>// default getter </i>

          def fahrenheit = ....           <i>// the same as original</i>
          }
      </code></pre>
    the defs v1 and v2 are implicitly created getters and setter. v2 doesn't have a setter method since it is <em>val</em>. <br />
    Here we special syntax: <code>= _</code> which is <em><b>default initializer</b></em>, which initialize the variable for default one (numbers - 0, strings - "", boolean - false, reference types - null).
    <p>As we see in example we can define setter and getter without creating field</p>
</div>

<h2>Casting</h2>
<div>
    We can check runtime type of an object and cast to other type.
    <ul>
        <li><code>o.isIstanceOf[T]</code>, check if <code>o</code> is type <code>T</code></li>
        <li><code>o.asIstanceOf[T]</code>, casts o to type T. Raises <code>java.lang.ClassCastException</code> when such operation can not be performed</li>
    </ul>
</div>

<h2>Special methods</h2>
<div>
    <ul>
        <li><code>apply</code>. <br />
            Every call on the object is actually call on this method. It is widely used by container classes to get / set on some index.
			<pre><code class="scala">
                val x = new SomeClass()
                x(4, 'a')         <i>// compiles to x.apply(4, 'a')</i>
            </code></pre>
        </li>
    </ul>
</div>

<h2 id="inheritance">Inheritance</h2>
<div>
    Scala goes the same mode of inheritance as Java - we can have <em>abstract classes</em>, and every class can have only one <em>base class</em>.
    <p>To make inheritance we use <em>extends</em> keyword, which goes just after primary constructor declaration</p>
    primary constructor <b>must call some base class constructor</b> by applying arguments to base class name (or leave empty when there is constructor with empty arguments list).
    <h5>Inheritance with repeated arguments</h5>
    <div>
        There is some hack when the constructor contain <a href="#repeated_arguments">repeated arguments</a>. There is special form to applying them.<br />
        Consider following examples.
    </div>
    <br />
    Examples:
		<pre><code class="scala">
            class A1(x: Int) {
            val param = init(x)                       <i>// Base calls methods to initiate x</i>
            def init(x: Int) = x*2
            }

            class A2(x: Int) extends A1(f(x)) {
            override def init(x: Int) = x*4
            }
            object A2 {
            def f(x:Int) = x+3
            }

            val b = new A2(1)                           <i>// Base primary constructor calls override init method</i>
            println(b.param)                            <i>// prints 16</i>


            class A(name: String, vals: String*)

            class B(name: String, vals: String*) extends A(name, vals: _*)   <i>// <b>look</b> how we apply vals! </i>
        </code></pre>
</div>

<h2>Self reference</h2>
<div>
    Every class/trait scope has predefined <b><em>this</em></b> value which is self reference to current object of the class.<br />
    Using <em>this</em> we can get to object fields which could be hidden by current scope.
    <p>From Scala Ref. §6.5:<br />
        The expression <em>this</em> can appear in the statement part of a template or compound type. It stands for the object being defined by the innermost template or compound type enclosing the reference. If this is a compound type, the type of <em>this</em> is that compound type. If it is a template of a class or object definition with simple name C, the type of <em>this</em> is the same as the type of C.this.
    </p>

    <h3>Self reference aliases</h3>
    <div>
        We can make some aliases to <em>this</em> on class level scope.<br />
        This is useful when we are in inner class definition, and want get some field/method from the outer class.
        The following example demonstrate how to make it:
			<pre><code class="scala">
                class O {
                selfO =>
                val name = "O"
                trait I {
                selfI =>
                val name = "I"
                def test() {
                this.name           <i>// refers to "I"</i>
                selfI.name          <i>// refers to "I"</i>
                O.this.name         <i>// refers to "O"</i>
                selfO.name          <i>// refers to "O"</i>
                }
                }
                }
            </code></pre>
    </div>

    <h3 id="self-type-annotations">Self type annotations</h3>
    <div>
        We can make an assertion on a class to be of some type.<br />
        This creates inheritance dependency which must be satisfied when:
        <ul>
            <li>instantiating an object</li>
            <li>creating subclasses</li>
        </ul>
        <p>For example we want to create class Foo which must be also the type of Bar1 and Bar2:</p>
			<pre><code class="scala">
                trait Bar1
                trait Bar2
                class Foo {
                self : Bar1 with Bar2 =>             <i>// here we can change self name for whatever we want, but keyword</i>
                ...
                }

                val x = new Foo                        <i>// error: class Foo cannot be instantiated because it does not conform to its self-type Foo with Bar1 and Bar2</i>
                val x = new Foo with Bar1 with Bar2    <i>// OK</i>
            </code></pre>

        More info about <em>self type annotations</em> on <a href="http://www.scala-lang.org/node/124">scala pages</a>

        <h4><a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a></h4>
        <div>
            Here I present some interesting constraint on class using <em>self reference type annotations</em>
				<pre><code class="scala">
                    <i>// we want to create base parametric type which requires that in subtypes the type parameter will be the subtype itself:</i>
                    <i>// So the constraint is that the subtypes must be the form of:</i>
                    <i>//      S extends Base[S]</i>

                    abstract class Base[Sub] {
                    self:Sub =&gt;
                    def add(s:Sub) : Sub
                    }

                    case class Vec2(x:Double,y:Double) extends Base[Vec2] {            <i>// Ok</i>
                    def add(that:Vec2) = Vec2(this.x+that.x, this.y+that.y)
                    }

                    <i>// attempts to cheat with inheritance won't work:</i>
                    case class Foo extends Base[Vec2]                            <i>// error: illegal inheritance;</i>
                </code></pre>
        </div>

        <h5>Covariance example</h5>
        <div>
            Sometimes we need a covariance types.<br />
            In the previous example, if class <code>Base</code> would have some filed, lets say <code>base_field</code>, and if in <code>add</code> method we would refer to that field, we get an error, that class Sub doesn't have such field. class <code>Base</code> has, but inside definition of <code>Base</code> we can refer only to fields from <code>Sub</code>.<br />
            The example below explain how to resolve this.

            <p>Consider a class Child with a method roomWith(aChild), which asserts that self and aChild are roommates. If there are two subclasses Boy and Girl, you will want to subclass this method in both with signatures roomWith(aBoy) and roomWith(aGirl) respectively, while doing the actual work (which is the same in both cases, presumably) in the Child method. The type system should check the correctness of every call.</p>
				<pre><code class="scala">
                    abstract class Child[C &lt;: Child[C]] {
                    self : C =&gt;
                    var roomie : Option[C] = None

                    def roomWith(aChild : C)= {
                    roomie = Some(aChild)
                    aChild.roomie = Some(this)
                    }
                    }
                    class Boy extends Child[Boy]
                    class Girl extends Child[Girls]

                    val b1 = Boy
                    val b2 = Boy
                    val c1 = Girl

                    b1.roomWith(b2)
                    b1.roomWith(c1)                      <i>// error</i>
                </code></pre>
        </div>
    </div>
    <hr />
    Look the <a href="#self-type-annotations">self type annotations</a> section to get more information.
</div>
</div><!-- klasa -->


<h1>FOR, Generators, Monads</h1>
<div>
    Methods on numbers: <b>to, until</b>, eg: <code>1 to 5</code>

    <h2 id="for_expression">For expression</h2>
    <div>
        <h5>Generator</h5>
			<pre><code class="scala">
                for (<i>seq</i>) yield <i>expr</i>
            </code></pre>
        <h5>For loop</h5>
			<pre><code class="scala">
                for (<i>seq</i>) <i>expr</i>
            </code></pre>
        <em>seq</em> is a sequence of <em>generators, definitions, filters</em> with semicolons  between successive elements.<br />
        <em>generator, definition, filters</em> are some types of match expression which is matched one-by-one all elements from the iterator. If the match fails (eg iterator is not a "iterator", or it's Unit, definition error ...), then is simply discarded from the iteration (instead throwing exception).
			<pre><code class="scala">
                for((a,b) &lt;-range             <i>// generator</i>
                if  x > 10       <i>// filter</i>
                if ...;          <i>// needs <b>;</b> before nested expression</i>
                y &lt;- range if ...        <i>// nested generator + filter expression</i>
                CaseCl(tmp1, tmp2) = y.some_function;  <i>// definition</i>
                if (predicate tmp1)                    <i>// other filter</i>
                ) [yield] {
                block code                  <i>// returns something</i>
                }
            </code></pre>
        We can use {} instead () to avoid putting ';' after each sentence
        <p>
            <b>Caution</b> the definition part is computed every time new value is taken.<br />
            If definition part doesn't depends on variables bound by some generator it is better to put it outside for expression:
        </p>
			<pre><code class="scala">
                for (x &lt;- 1 to 1000; y = expensiveComputationNotInvolvingX)   <i>// BAD to put y here</i>
                yield x * y

                <i>// Better solution</i>
                val y = expensiveComputationNotInvolvingX
                for (x &lt;- 1 to 1000) yield x * y
            </code></pre>

        <h3>For and high order function</h3>
        <div>
            Every <code>for ... yield ... </code> expression is translated to some composition of <em>map, flatMap and withFilter</em> functions.<br />
            Every <code>for</code> loop is translated to some composition of <em>withFilter, foreach</em> functions.
            <p><code>map, flatMap, withFilter</code> expects some function as a first argument, which can be <a href="#case_seqence_as_partial_function">partial function</a><br />
                This is used to convert <em>for</em> expression to hight order functions</p>
				<pre><code class="scala">
                    for ((x1 , ..., xn ) &lt;- expr1 ) yield expr2
                    <i>// is translates to:</i>
                    expr1 .map { case (x1 , ..., xn ) => expr2 }

                    for (pat &lt;- expr1 ) yield expr2
                    <i>// pat is general pattern, thus translation is a bit complicated:</i>
                    expr1 withFilter {
                    case pat => true
                    case _ => false      <i>// this guarantees that match never throw a MatchError</i>
                    } map {
                    case pat => expr2
                    }
                </code></pre>
        </div>
    </div>


    <h2>FOR generalization</h2>
    <div>
        As we've seen before, <em>for expressions</em> are translated to <em>map, flatMap, withFilter, foreach</em> composition. Thus it is possible to use for on every type which implements this kind of functions!<br />
        But it's also possible to define a subset of these methods, and thereby support a subset of all possible for expressions or loops. Here are the precise rules:
        <ul>
            <li><em>map</em> allows for expressions consisting of a single generator</li>
            <li><em>map, flatMap</em> allows for expressions consisting of a several generators</li>
            <li><em>foreach</em> allows for loops (both single and multiple)</li>
            <li><em>withFilter</em> allows filter expression</li>
        </ul>
        Scala defines no typing rules for the for expressions themselves, and does not require that methods map, flatMap, withFilter, or foreach to have any particular type signatures.
        <h3>Monads</h3>
        <div>
            <em>Monad</em> is a type that implements <em>map, flatMap, withFilter</em> methods.<br />
            From functional point of view <em>monads</em> can explain a large number of types with computations, ranging from collections, to computations with state and I/O, back- tracking computations, and transactions, to name but a few.
            <p>Furthermore, you can characterize every monad by map, flatMap, and withFilter, plus a “unit” (<em>Monoid</em>) constructor that produces a monad from an element value. In an object oriented language, this “unit” constructor is simply an instance constructor or a factory method.
            </p>
        </div>
        <hr />
        All this suggests that the concept of <em>for expression</em> is more general than just iteration over a collection, and indeed it is. For instance, for expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values. Watch out in the Scala libraries for occurrences of <em>map, flatMap, withFilter</em> — when they are present, for expressions suggest themselves as a concise way of manipulating elements of the type.
    </div>


</div>

<h1>Exceptions</h1>
<div>
    Exceptions are raised through <em>throw</em> keyword. Throw statement has a return type: <b>Nothing</b> and it match to every other type.
    <h2>checked exceptions</h2>
    <div>
        Scala does not require you to catch checked exceptions, or declare
        them in a throws clause. You can declare a throws clause if you wish with
        the @throws annotation, but it is not required.
    </div>

    <h2>try catch expression</h2>
    <div>
        <code>try-catch-finally</code> returns value. The value is returned only from try (if no exception occur), or catch (if exception is thrown and catch). The value computed in <code>finally</code> clause is dropped. Finally should not normally change the value computed in the main body or a catch clause of the try.
        If a finally clause includes an explicit return statement, or throws an exception, that return value or exception will "overrule" any previous one
        that originated in the try block or one of its catch clauses. See more in <em>Programming in Scala e2</em> (page 172).

    </div>

	<pre><code class="scala">
        try {
        val f = new FileReader("input.txt")
        ...
        } catch {
        case ex: FileNotFoundException => // handle missing file
        case ex: IOException => ...
        } finally {
        file.close()
        }
    </code></pre>

</div>


<h1>Functions and Methods</h1>
<div>
<h2 class="none"></h2>
Scala has <em>methods</em> (which are java derived type, part of some class), and <em>functions</em>, which are first order types.
<br /><br />
Methods
<ul>
    <li>we make them by <b>def</b> keyword</li>
    <li>the same meaning like in Java</li>
    <li>they are part of a class</li>
    <li>they are strict against parameters and call</li>
    <li>the are not first class object, so we can't simply use them to assignments</li>
    <li>there is exception to the above rule: we can use simply methods names in places where a function is required (passing arguments)</li>
    <li>can be generic</li>
    <li>can be overwrite</li>
</ul>

Functions values:
<ul>
    <li>we make them by <em>function literals</em>: <b>=&gt;</b> keyword and <em>case sequences</em>, look in <a href="#Partial_functions">match chapter</a></li>
    <li>we can assign them to <code>var, val</code></li>
    <li>they are instances of FunctionX class (eg <code>Function3[Int, Int, Double]</code>)</li>
    <li>they have methods: <code>apply</code> to call , <code>curry</code> to transform to curried form (each argument separately passed)</li>
    <li>other methods from FunctionX class: <code>toString, andThen, compose, ...</code></li>
    <li>they are flexible against call and parameters</li>
    <li>the are first class object</li>
    <li>the like to be curried</li>
    <li>can't be generic type</li>
    <li>can't be overwrite</li>
</ul>
<br />

<div class="small">
    Methods are converted to a function only if the target type specifies it, or else if followed by '_'. This is arguably not very elegant, so why did we do it? <br />
    In fact the first version of Scala did not distinguish methods from functions, and could do partial application without the '_'. Unfortunately, this did not work very well in practice. Programmers often forget function arguments and Scala's subtyping discipline is too lenient to catch many of those errors. E.g.
    <code>println("abc".length)</code>  might print &lt;function&gt; if you forgot the parentheses after length.
    <p>
        Quite good article about this can be found <a href="http://stackoverflow.com/questions/2529184/difference-between-method-and-function-in-scala">here</a></p>
</div>
CAUTION: Converting from a method to a function loses parameter defaults.

<h3>FunctionX class</h3>
<div>
    In Scala every function is instance of class FunctionX, where X is a number of function arguments.<br />
    So <code>(_:Int) + (_:Double)</code> is instance of <code>Function1[Int, Double]</code>, and <code>def f = 1</code> - is a constant function, instance of <code>Function0[Int]</code>.
    <p>
        Scala have syntactic sugar for function types:<br />
        <code>() => R</code>  stands for Function0[R]<br />
        <code>A, B => R</code>  stands for Function2[A, B, R] <br />
        and so on ...
    </p>
</div>
<h3>_ on functions</h3>
<div>
    "<code>someMethod _</code>" wraps <code>someMethod</code> to function value, whose <em>apply</em> method is exactly someMethod. <br />
    "_" is used to make partial functions - to create new function value which curry missing arguments.
</div>

Example:
	<pre><code class="scala">
        val nums = List(1,2,3)
        val.foreach(println _)           <i>// ok function value is required, println is converted to function value</i>
        val.foreach(println)             <i>// ok, compiler expects function</i>

        def succ1(i: Int) = i+1
        val succ2 = { i: Int => i+1 }
        var p = succ1                    <i>// ERROR succ is not a first class value</i>
        var p = succ1 _                  <i>// ok, succ is converted to function value by _ </i>
        var p: Int=>Int = succ1          <i>// ok, compiler expects function</i>
        <i>// succ2 == p ==succ1 _     ; both equal by type and semantic</i>

        def method_g[T](x:T) = x.toString.substring(0,4)
        val fun_g = [T](x:T) => x.toString.substring(0,4)  <i>// ERROR: functions can't be generic </i>

        <i>//**  but we can obey restriction from fg:  **</i>
        class Cfun_g[T] extends Function1[T,String] {
        def apply(x:T) = x.toString.substring(0,4)
        }
        val fun_g = new Cfun_g[String]
        fun_g("this is a string")
    </code></pre>


<h3>local functions and placeholders</h3>
<div>
    the placeholder can be used only once per argument.  Multiple underscores mean multiple parameters, not reuse of a single parameter repeatedly.
	  <pre><code class="scala">
          someList.foreach(_ + _)
      </code></pre>
</div>

<h2>Assertions, arguments validation</h2>
<div>
    <ul>
        <li><code>require</code> -> raises IllegalArgumentException - use to validate function / constructor arguments </li>
        <li><code>assertion</code> -> raises AssertionError</li>
    </ul>
</div>

<h2>Partially applied functions</h2>
<div>
    <p>applying to none of arguments:</p>
    <code>var f = someFunction _</code>
    <p>applying to some arguments, eg function has 3 arguments of types String, Int, Int:</p>
    <code>var f = someFunction("hej", _: Int, 3)</code>
</div>

<h2>Implementation of <em>val</em> and <em>var</em></h2>
<div>
    <code>val c=1</code> is implemented as a pair:
	  <pre><code class="scala">
          private final int c;
          public int c();                    <i>// getter</i>
      </code></pre>

    <code>var v=1</code> is implemented as a triple:
	  <pre><code class="scala">
          private int v;
          public int  v();                   <i>// getter</i>
          public void v_$eq(int);            <i>// setter</i>
      </code></pre>

    <code>val f = {x:Int => x+1}</code> is implemented as a pair:
	  <pre><code class="scala">
          private final scala.Function1 f;   <i>// object to keep function value as a constant (f is a val)</i>
          public scala.Function1 vf1();      <i>// getter method to the function</i>
      </code></pre>

    <code>var f = {x:Int => x+1}</code> is implemented as a triple:
	  <pre><code class="scala">
          private scala.Function1 f;         <i>// object to keep function value as a variable (f is var)</i>
          public scala.Function1 vf1();      <i>// getter method to the function</i>
          public void vf_$eq( Function1 );   <i>// setter</i>
      </code></pre>
</div>

<h2>Declaring function arguments</h2>
<div>
    <h3 id="repeated_arguments">repeated arguments</h3>
    <div>
		<pre><code class="scala">
            def echo(args: String*) = for(a &lt;- args) println(a)
            def pass_to_echo(args: String*) = echo(args: _*)

            var arr = Array("jeden", "dwa")
            echo("jeden", "dwa")
            echo(arr)                       <i>// Error</i>
            echo(arr: _*)                   <i>// OK</i>
        </code></pre>
    </div>

    <h3>Named arguments</h3>
    <div>
			  <pre><code class="scala">
                  def f(arg1: Int, arg2: String) = ...
                  f(arg2="hej", arg1=1)
              </code></pre>
        It is also possible to mix positional and named arguments. In that case, the
        positional arguments come first.
    </div>

    <h3>Default arguments</h3>
    <div>
			  <pre><code class="scala">
                  def f(arg: Int = 2)
              </code></pre>
    </div>


    <h3>by name</h3>
    <div>
        Scala arguments can be passed by name. When an expression passed as an argument is not computed greedy, before a function call, but every time the argument is used in a function.
			<pre><code class="scala">
                def f(a: => Unit) = a;a                             <i>// a is an argument passed by name</i>
                f(println("hej"))                                   <i>// outputs two lines of "hej"</i>

                var actions: Listbuffer[()=>Unit] = ListBuffer()    <i>// List with some operation to do</i>
                def insert(condition)(operation: =>Unit) = {
                if(condition) actions.append(() => operation)
                }
            </code></pre>
        In the previous example insert puts an unevaluated expression which type is <em>Unit</em> to the action list as a function, which evaluates this expression (use variable). <br />
			<pre><code class="scala">
                var count = 0
                val e = { count += 1 }              <i>// Fake. The expression is called, and e==1, count==1</i>
                insert(true){
                println("incrementing")
                count += 1
                }                                   <i>// nothing is print, count is not incremented</i>
                insert(true)(println("hej"))

                actions(0)                          <i>// returns a function which evaluates {println("incrementing"); count+=1}</i>
                actions(0)()                        <i>// count == 2</i>
                actions(0)()                        <i>// count == 3</i>
                actions(1)()                        <i>// output "hej" to console</i>
            </code></pre>

        <h5>Short-circuit evaluation of &amp;&amp;</h5>
        <div>
            The semantic of <code>&amp;&amp;</code> is a method from Boolean class is like in other languages. The second argument is evaluated only when firs is true, and is done with argument passed by name, which look similar to:
				<pre><code class="scala">
                    class Bollean(left) ...
                    def  &&(right: ()=>Bollean) =
                    if(left) right
                    else false
                </code></pre>
        </div>
    </div>
</div>

<h2 id="method_overloading">Method overloading</h2>
<div>
    Scala allows for method overloading.<br />
    Overloaded method are methods with the same name, but different argument types.<br />
    Method overloading is the mechanism to choose right method based on arguments type putted to method call.<br />
    Compiler will chose the method based on invocation arguments list, and look for:
    <ul>
        <li>argument type - the compiler will choose the method with the most specific argument type:
				<pre><code class="scala">
                    def foo(a: List[Int]): Unit = ...
                    def foo(a: Seq[Int]): Unit  = ...

                    foo(1::2::Nil)          <i> compiler will use foo: List[Int] => Unit</i>
                </code></pre>
        </li>
        <li>arguments number - the compiler will use method with appropriate arguments length</li>
    </ul>

    <h3>Limitations of method overloading</h3>
    <div>
        Due to JVM <em>type erasure</em> Scala has the same limitations for method overloading as Java has.<br />
        For runtime system the both <code>foo</code> methods below has the same type:
				<pre><code class="scala">
                    def foo(x: List[Int])
                    def foo(x: List[Boolean])
                </code></pre>
        So in client code runtime can't figure out which one to use.
        We can pass this limitation using <a href="#union_types">union types</a> described in tips section.<br />
        Quiet interesting solution is to use functions with different arguments number (so that functions after type erasure have different head), described in <a href="http://stackoverflow.com/questions/4982552/scala-method-overloading-over-generic-types">http://stackoverflow.com/questions/4982552/scala-method-overloading-over-generic-types</a>.
        <p>
            Other possibility would be to use case classes family + pattern matching + implicit conversion from desired generic types to case classes. More: <a href="http://jim-mcbeath.blogspot.com/2008/10/polymorphism-using-implicit-conversions.html">http://jim-mcbeath.blogspot.com/2008/10/polymorphism-using-implicit-conversions.html</a></p>
    </div>
    Scala code guidelines <b>avoid method overloading</b>. The reasons are:
    <ul>
        <li>limitation with generic types</li>
        <li>disambiguation with function passing:
				<pre><code class="scala">
                    <i>// assuming above foo definition</i>
                    val my_fun = foo _            <i>// what is the type of my_fun? which foo to use?</i>
                </code></pre>
        </li>
        <li>disambiguation with applying implicit views:
				<pre><code class="scala">
                    <i>// assuming above foo definition</i>
                    <i>//   and we have some implicit conversion from String to Int and Boolean</i>
                    foo("")                       <i>// which implicit conversion use: String => Int or String => Boolean?</i>
                </code></pre>
        </li>
        <li>can make default parameters unusable:
				  <pre><code class="scala">
                      def f(s: String) = ...
                      def f(s: String, cond: Boolean = True) = ...
                  </code></pre>
        </li>
        <li>more: <a href="http://stackoverflow.com/questions/2510108/why-avoid-method-overloading">http://stackoverflow.com/questions/2510108/why-avoid-method-overloading</a></li>
    </ul>

</div>
</div>


<h1 id="traits">Traits</h1>
<div>
    <h2>Using Traits</h2>
    <div>
        We use traits by writing keyword <em>with</em> just after class name and inheritance part. <br />
        It can be declared both in class definition or in class initialization.<br/>
        If the trait has super class - then the trait can be only mixed into a class that also extends this super class.
        <p>
            Trait can has a super call on a method declared abstract. Such calls are illegal for normal classes. <br />Since super calls in a trait are dynamically bound, the super call for a abstract method in a trait will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method. This arrangement is frequently needed with traits that implement stackable modifications. To tell the compiler you are doing this on purpose, you
            must mark such methods as abstract override.
        </p>
        <p>
            The order of mixins is significant. <br />
            The method call order is determined by <em>linearization</em>. Roughly speaking, when you call a method on a class with mixins, the method in the trait furthest to the right is called first. If that method calls super, it invokes the method in the next trait to its left (of from <em>parent trait</em> - not class!), and so on.<br />
            The linearization of class is computed from back (of the declaration order) to front as follows. The last part of the linearization <u>is superclass</u>.
            Traits can extend other traits. In that case the overwrite version of method is called first. (eg <em>T2 extends T1; class X with T2 with T1; var x = new X</em>, and all has f method, if T2 override f method then T2.f is called first in expression x.f)
        </p>

        Example:
	  <pre><code class="scala">
          abstract class IntQueue {
          def get(): Int
          def put(x: Int)
          }

          class BasicIntQueue extends IntQueue {
          import scala.collection.mutable.ArrayBuffer
          private val buf = new ArrayBuffer[Int]
          def get() = buf.remove(0)
          def put(x: Int) { buf += x }
          }

          trait Doubling extends IntQueue {
          abstract override def put(x: Int) { super.put(2 * x) }
          }
          trait Incrementing extends IntQueue {
          abstract override def put(x: Int) { super.put(x + 1) }
          }


          class MyQueue extends BasicIntQueue with Doubling

          val queue = new MyQueue with Incrementing
          val queue = new BasicIntQueue with Doubling with Incrementing


          <i>// example with parameter constructor</i>
          class WithParameter(arg: Int) extends MyQueue with  Doubling
      </code></pre>
        <h5>Interestings</h5>
        <ul>
            <li><a href="http://stackoverflow.com/questions/7051615/rules-for-mixing-same-trait-several-times">some puzzle with trait composition</a></li>
        </ul>
    </div>

    <h2>Interesting traits</h2>
    <div>
        <ul>
            <li><code>Ordered</code>. One abstract method which needs to be implemented: compare(self: X): Int
                <br/> it provides implementation for: &lt; &gt; &lt;= ...</li>
            <li><code>Application</code> - doesn't work in multi thread application, has no access to commandline (startup) arguments. Is not well optimized</li>
            <li><code>App</code> - take care about every downside from Application trait. Works in multithreading applications, has access to commandline arguments, it's optimized. Available in Scala &gt; 2.9. More in Scala API docs</li>
            <li><code>DelayedInit</code>. The class which implements it, the code from main constructor (with variables and expressions evaluated at initialization time) is moved to <code>delayedInit()</code> method. At the end we've got a control about initialization time of an object. To correctly use an object we need to call delayedInit method before.</li>
            <li><code>Dynamic</code>. Trait to make dynamic nature of constructed object, which mixin this trait. More in <a href="http://docs.scala-lang.org/sips/pending/type-dynamic.html">Dynamic proposal</a></li>
        </ul>
    </div>
</div>

<h1>Packages</h1>
<div>
<ul>
    <li>First, you can place the contents of an entire file into a package by putting a package clause at the top of the file.
	    <pre><code class="scala">
            package bobsrockets.navigation
        </code></pre>
    </li>
    <li>Follow a package clause by a section in curly braces that contains the definitions that go into the package. This syntax is called a packaging.
	     <pre><code class="scala">
             package bobsrockets.navigation {
             class Navigator
             }	 </code></pre>
    </li>
</ul>

<h2>Packages: compilation and runtime</h2>
<div>
    <p>The binary file structure depends on packages, not the source file structure. All definitions are compiled to exactly one binary .class file based on package in which the definition is placed</p>
    <p>All the class, traits and companion objects from package Pack1.Pack1_1 in some module (file) are compiled to Pack1/Pack1_1 subdirectory of the output directory.</p>

    <p>In order to run an class Main which is in package Pack1.Pack1_1 you need to run: <b><code>scala Pack1.Pack1_1.Main</code></b><br />
        You need to assure that directory Pack1 is in your <em>CLASSPATH</em> by either be in directory Pack1 or add path to Pack1 to <em>CLASSPATH</em> through -cp option or setting CLASSPATH environment variable.
    </p>

    <h5>Common exceptions during running a main class</h5>
    <div>
        While trying to run a main class you can encounter following exceptions:
        <ul>
            <li><code>Exception in thread "main" java.lang.RuntimeException: Cannot figure out how to run target: Main</code><br />
                JVM can't find class Main.<br />
                Probably the class Main is in some package or the class file is not in your <em>CLASSPATH</em>. If you can, check in the source file if class Main is in some package or check your classpath. If you run Main class from the directory where Main.class file is, then probably it is a problem with package (but you should check classpath as well by running <code>scala -cp . test.Main</code>)
            </li>
            <li><code>Exception in thread "main" java.lang.RuntimeException: Cannot figure out how to run target: test.Main</code><br />
                JVM can't find class test.Main.<br />
                You run test.Main so you explicitly call Main class from test package. The Main.class file is stored somewhere in directory test (This is a JVM packaging rule).<br />
                Probably the test directory (the directory when class Main resist) is not in your classpath. Try to run class one more time by specifying classpath.<br />
                Eg: you are in test directory itself. run:<br />
                <code>scala -cp .. test.Main</code>
            </li>
            <li>Exception in thread "main" java.lang.NoClassDefFoundError: Main (wrong name: test/Main)<br />
                The class Main doesn't have main method. <br />
                The class you are trying to run from JVM needs to have a main method.<br />
                The main method in Scala must resist in an object and has the following definition:
                <pre><code class="scala">def main(args: Array[String]) { ... }</code></pre>
                The exception was raised because the class (object) doesn't has the main method or you try to call wrong class - forgot to specify package.<br />
                Check the source file if there is an object with the main method and if the module is contained in package X.Y you need to specify it in runtime: <code>scala X.Y.Main</code> - assuring that X is in your CLASSPATH.
            </li>
        </ul>
    </div>
</div>

<h2>Accessing names in packages</h2>
<div>
    If code resists in the same package, Scala allows to use short, unqualified names.<br />
    Otherwise you must use full names (like java.collection...). <br />
    When using the curly-braces packaging syntax, all names accessible in scopes outside the packaging are also available inside it.
    <p>If There are to packages ie: <em>launch</em> one in global scope, second in package bob,
        and you have a method that access package launch, then that methods refers to bob.launch.
    </p>
    If you want to access global launch you need to write:
	    <pre><code class="scala">
            _root_.launch
        </code></pre>
    Put another way, every top-level package you can write is treated as a member of package <code>_root_</code>.
</div>

<h2>Imports</h2>
<div>
    An import clause makes members of a package or object available by their names alone without needing to prefix them by the package or object name.
	  <pre><code class="scala">
          import bobsdelights.Fruit <i>// easy access to Fruit</i>
          import bobsdelights._     <i>// easy access to all members of bobsdelights</i>
      </code></pre>

    <h3>Special of import in Scala</h3>
    <div>
        Scala’s import clauses are quite a bit more flexible than Java’s.
        <ul>
            <li>may appear anywhere</li>
            <li>may refer to objects (singleton or regular) in addition to packages</li>
            <li>let you rename and hide some of the imported members</li>
            <li> they can import packages themselves, not just their non-package members. <br />
                For example, the package java.util.regex is imported. This makes regex usable as a simple name. To access the Pattern singleton object from the java.util.regex package, you can just say, regex.Pattern.
            </li>

        </ul>
        Examples:
		<pre><code class="scala">
            <i>// import a simple name x. This includes x in the set of imported names</i>
            import x

            def showFruit(fruit: Fruit) {
            import fruit._
            println(name +"s are "+ color)  <i>// the same as fruit.name, fruit.color</i>
            }

            <i>// this import to objects from Fruits and renames Apple</i>
            import Fruits.{Apple => McIntosh, Orange}

            <i>// imports all names from Fruits and renames Apple</i>
            import Fruits.{Apple => McIntosh, _}

            <i>// imports all members of Fruits except Pear</i>
            import Fruits.{Pear => _, _}
        </code></pre>
    </div>

    <h3>Implicit imports</h3>
    <div>
        Scala adds some imports implicitly to every program. They are:
        <ul>
            <li>java.lang._</li>
            <li>scala._</li>
            <li>Predef._</li>
        </ul>
        The Predef object contains many definitions of types, methods, and implicit conversions that are commonly used on Scala programs.
    </div>

</div>

<h2>Access modifiers</h2>
<div>
    Members of packages, classes, or objects can be labeled with the access modifiers private and protected.
    <h3>Private members</h3>
    <div>
        A member labeled private is visible only inside the class or (and companion) object that contains the member definition. In Scala, this rule applies also for inner classes (In Java not). Class-private or object-private members may not be abstract, and may not have or override modifiers.
        <h6>Caution</h6>
        Private members <b>can't be overridden</b>. It is to prevent changes in class behaviour injected by descendants. The concept here is very similar to C++ one - each ancestor holds its own copy of members until a special methods (virtual inheritance, for example) is invoked.<br />
        So if we mixin two traits with the same private member (but different value) - the final class will have two different fields. It won't be override.
    </div>

    <h3>Protected members</h3>
    <div>
        A protected member is only accessible from subclasses of the class in which the member is defined. In Java such accesses are also possible from other classes in the same package.
    </div>

    <h3>Public members</h3>
    <div>
        Every member not labelled private or protected is public.
    </div>

    <h3 id="scope_of_protection">Scope of protection</h3>
    <div>
        Access modifiers in Scala can be augmented with qualifiers. A modifier of the form private[X] or protected[X] means that access is private or protected “up to” X, where X designates some enclosing package, class or singleton object. <br />
        They enable you to express Java’s accessibility notions such as package private, package protected, or private up to outermost class which are not directly expressible with simple modifiers in Scala.
        <p>Class labeled <em>private[bobsrockets]</em> means that is visible in all classes and objects that are contained in package bobsrockets, but all code outside package bobsrockets can't access this class
        </p>
        <p>Class labeled <b>private[this]</b> allows access only from same object - any access must be made from the very same instance.<br />
            Interesting is a field type: <code>private[this] val</code> - nobody can modify it, and only the object itself has access to its value. There is proposal for optimization - that this field wouldn't take any memory space in object, and in places where it is used the value would be compiled in (as a temporary value).
        </p>
        <p>Modifier <em>protected[X]</em> in a class C allows access to the labeled definition in all subclasses of C and also within the enclosing package, class, or object X.
        </p>

        <h4>Visibility and companion objects</h4>
        <div>
            A class shares all its access rights with its companion object and vice verse.
            <p>One exception concerns protected static members. A protected static member of a Java class C can be accessed in all subclasses of C. By contrast, a protected member in a companion object makes no sense, as singleton objects don't have any subclasses.
            </p>
        </div>

    </div>

    <h3>Class hiding</h3>
    <div>
        <h5>Private class</h5>
        <div>
            If the class is private we can't even use it as a type
        </div>

        Private constructors and private members are one way to hide the initialization and representation of a class. Another, way is to hide the class itself and only export a trait that reveals the public interface. We use Trait to get access to the type and forbid using <em>new</em> on it.<br />
		<pre><code class="scala">
            trait Queue[T] {
            def head: T                              <i>// clients interface</i>
            ...
            }
            object Queue {
            def apply[T](xs: T*): Queue[T] =         <i>// clients factory method hiding actual constructor complexity</i>
            new QueueImpl[T](xs.toList, Nil)
            private class QueueImpl[T](              <i>// True class inaccessible from outside</i>
            private val p1: List[T],             <i>// private parameters, inaccessible even from Queue companion object</i>
            private val p2: List[T]
            ) extends Queue[T] {
            ...                                    <i>// Queue implementation</i>
            }
            }		</code></pre>

        So when we create QueueImpl object through factory method from Queue companion object, we can only access to Queue type. So the QueueImpl object is visible outside as a Queue type object, and has access only to fields from trait Queue.
        <p>This techniques is used only when we want to hide whole class</p>

    </div>
</div>

<h2>Package objects</h2>
<div>
    Any kind of definition that you can put inside a class (trait, class, function, variable), you can also put at the top level of a package.<br/>
    To do so, put the definitions in a <em>package object</em>. Each package is allowed to have one package object. Any definitions placed in a package object are considered members of the package itself.
    <p>We make <em>package object</em> by writing: <em>package object package_name {... }</em> <br />
        The contents of the curly braces can include any definitions you like.
    </p>
    Package objects are frequently used to hold package-wide type aliases and implicit conversions. The top-level <em>scala</em> package has a package object, and its definitions are available to all Scala code.
      <pre><code class="scala">
          //  file gardening/fruits/Fruit.scala
          package gardening.fruits
          case class Fruit(name: String, color: String)
          object apple extends Fruit("Apple", "green")

          //  in file gardening/fruits/package.scala
          package gardening
          package object fruits {
          val planted = List(apple, apple)
          def showFruit(fruit: Fruit) {
          println(fruit.name +"s are "+ fruit.color)
          }
          implicit def fruit2string(f: Fruit):String = f.name + " " + f.color
          } </code></pre>
    <p>Package objects are compiled to files named <code>package.class</code> which are the located in the directory of the package that they augment. So the package object fruits would be compiled to a class with fully qualified name <code>gardening.fruit.package</code> (Note that, even though package is a reserved word in Java and Scala, it is still allowed as part of a class name on the JVM level.
    </p>
</div>

</div> <!-- packages and imports -->

<h1>Assertions and Unit testing</h1>
<div>
    <h2>Assertions</h2>
    <div>
        <p>Assertions can be turned on/off (so the Assertions error are thrown or not by assert / ensuring ) using JVM command line flags -ea, -da
        </p>
        <code>Predef.assert(assertion: Boolean, [message: => Any]) :Unit</code><br />
        if assertion falls then AssertionError is thrown with message (any object) as explanation. The <code>assert</code> will call <code>toString</code> on it to get string explanation.
        <br /><br />
        <b>ensuring</b> is a method of class <code>Ensuring</code>.<br />
        There exists implicit conversion from Any type to Ensuring, so we can coll from Any instruction this method. The constructor takes an object to operate with while calling ensuring method<br/>
        There are two methods declaration:
        <ul>
            <li><code>ensuring(cond: (A) => Boolean, [msg: => Any]): A</code><br/>
                this takes predicate function and applying the contained object to that predicate.
            </li>
            <li><code>ensuring(cond: Boolean, [msg: => Any]): A</code><br/>
            </li>
        </ul>
        While <em>cond</em> falls ensuring will throws <code>AssertionError</code> with optional msg as an argument.
        Example:
	  <pre><code class="scala">
          var x = 2
          if(x&lt;2)
          x
          else {
          val y: Int = 2
          y+x
          } ensuring ( _ >= 4, "x is >= 2 so y+x is >=4")
      </code></pre>
        the block after else returns (x+y):Int, which is converted to Ensuring with itself as a parameter. Then is applied to cond method ( x+y >= 4 ) and if the result is false exception is thrown.
    </div>

    <h2>Unit testing</h2>
    <div>
        Just use one of Java tools, or new tools for Scala as <em>ScalaTest, ScalaCheck</em>...
    </div>
</div>


<h1>Case Classes and pattern matching</h1>
<div id="case_classes" >
Special type of classes to support pattern matching.<br />
Case classes has several conventions:
<ul>
    <li>no need to write <code>new</code> keyword when instantiating. They has factory methods, eg <code>val v = Num(1)</code></li>
    <li>All arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields</li>
    <li>Compiler adds “natural” implementations of method <code>toString hashCode, and equals</code> to your class. They will print, hash, and compare a whole tree consisting of the class and (recursively) all its arguments. Since == in Scala always delegates to equals, this means that elements of case classes are always compared structurally.
    </li>
    <li>Compiler adds a copy method to your class. This method is useful for making a new instance of the class that is the same as another one except attributes passed as named parameters which has different values </li>
</ul>

<h2>match</h2>
<div>
    <em>selector <code>match</code>{ (pattern => expression)* }</em>.<br />
    Pattern can be:
    <ul>
        <li>constants: of type (Int, MyClass), val, companion object, literals (eg: 3, "tree")</li>
        <li>variable: free variable (then it match everything), variable symbol (then it evaluate to variable in the symbol) or case class instance (1::2::Nil)</li>
    </ul>
    Scala uses a simple lexical rule for variable disambiguation: a simple name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to be constants. To see the difference, create a lowercase alias pi form math.PI. <br />
    To use a lowercase name for a pattern constant, enclose the pattern in back-tricks (`pi`). Back-trick are use also to treat keyword as an ordinary identifier (eg `for`).
    <p>
        So when we want to use a variable to be used in match evaluation it must be <b>uppercase</b>, or lowercase wrote in form:</p>
	  <pre><code class="scala">
          var x = 2
          (1+1) match  {
          case `x`     => true      <i>// x is bind to variable x</i>
          case x       => true      <i>// always TRUE!, x is taken as a free variable, and is bind to match expression (1+1)</i>
          case X:                     =&gt; ...            <i>// only accepts a value equal to the value X (upper case here makes a difference)</i>
          case z if z==x => true    <i>// z is taken as a free variable and bind to match expression (1+1). The match is true when "<b>if</b>" evaluates to true</i>
          }	  </code></pre>
    The exception is also in infix operators (eg: <code>x::tail</code>) :
    <ul>
        <li>in an expression is equivalent to method call (<code>tail.::(x)</code>)</li>
        <li>in a pattern is equivalent is treated as a constructor pattern (<code>::(x, tail)</code>)</li>
    </ul>
    Expression part might be empty, then the return value is (): Unit<br />
    Example:
	  <pre><code class="scala">
          def simplify(expr: Expr): Expr = expr match {
          case UnOp("-", UnOp("-", e))  =&gt; e                  <i>// Double negation</i>
          case BinOp("+", e, Number(0)) =&gt; e                  <i>// Adding zero</i>
          case BinOp("*", e, Number(1)) =&gt; e                  <i>// Multiplying by one</i>
          case List(0, _*)             =&gt; println("found it") <i>// variable long sequence beginning with 0</i>
          case UnOp("abs", e @ UnOp("abs", _)) =&gt; e           <i>// when matching success e is bind to UnOp)"abs",_)</i>
          case BinOp("+", x, x) => BinOp("*", x, Number(2))   <i>// this fails, patterns must be <b>linear</b>.</i>
          <i>// pattern variable may only appear once in a pattern.</i>
          case BinOp("+", x, y) if x == y =&gt; ...              <i>// <b>pattern guard</b>. Reformulation of upper</i>
          case s:String if s(0) == 'a'    =&gt; ...              <i>// <b>pattern guard</b>. Reformulation of upper</i>
          case BinOp(op, l, r)  =&gt; BinOp(op, simplifyAll(l), simplifyAll(r))     <i>// recursive match further</i>

          // other matchers:
          case x: String              =&gt; s.length       <i>// any String</i>
          case x: Map[_, _]           =&gt; m.size         <i>// any Map, <b>we can't precise context</b> eg Map[_, Int] because of type erasure</i>
          case (x, y, ..., z)         =&gt; ...            <i>// only accept a tuple of the same arity</i>
          case Extr()                 =&gt; ...            <i>// only accept if Extr.unapply(expr) returns Some(Seq()) - some of something/empty sequence</i>
          case Extr(x)                =&gt; ...            <i>// only accept if Extr.unapply(expr) returns Some(Seq(x)) or Some(Tuple1(x))</i>
          case Extr(x, y, ..,z)       =&gt; ...            <i>// only accept if Extr.unapply(expr) returns Some(Seq(x,y,...,z)) or Some(TupleN(x,y,...z)) - the same arity</i>
          case x Extr y               =&gt; ..             <i>// only accept if Extr.unapply(expr) returns Some(Seq(x,y)) or Some((x,y))</i>
          case x | y | ... | z        =&gt; ...            <i>// accepts if any of the patterns is accepted (patterns may not contain assignable identifiers)</i>

          case _ =&gt; expr
          }	  </code></pre>

    <h3 class="none"></h3>
    <h4>Type parameters in Match</h4>
    <div>
        From Scala specification:<br />
        <p><em>A parametrized type pattern T [a(1), . . . , a(n)], where the a(i) are type variable patterns or wildcards _. This type pattern matches all values which match T for some arbitrary instantiation of the type variables and wildcards. The bounds or alias type of these type variable are determined as described in (§8.3).<br />
            ...<br />
            A type variable pattern is a simple identifier which starts with a lower case letter. However, the predefined primitive type aliases unit, boolean, byte, short, char, int, long, float, and double are not classified as type variable patterns.</em>
        </p>
        So if type parameter is lowercase it is taken as an free variable.
        <pre><code class="scala">
            case x Seq[a]  => ...       // this will match any Seq, and the type parameter will be bind to a
        </code></pre>
        The conclusion is we can't specify type parameters with full qualified names (like <code>java.lang.Integer</code>).
        <p>If we need to specify type from some package, we need to make an type alias starting from Upper letter:<br />
            <code>type JavaInt = java.lang.Integer</code>
        </p>
    </div>

    <h3>Sealed classes</h3>
    <div>
        In a pattern match, it's good to make sure you have covered all of the possible cases. In general, this is impossible in Scala, to compiler tell you which are possible cases, because new case classes can be defined at any time and in arbitrary compilation units.
        A <b>sealed class</b> cannot have any new subclasses added except the ones in the same file.<br/>
        We make them by putting the <em>sealed</em> keyword in the very front of the class.
        This is very useful for pattern matching, because it means you only need to worry about the subclasses you already know about and you get better compiler support as well.
        <br/><br/>
        <h4>unchecked annotation</h4>
        <div>
            The @unchecked annotation has a special meaning for pattern matching. If a match's selector expression carries this annotation, exhaustive checking for the patterns that follow will be suppressed. So compiler will not worrying about exhaustive cases.
		  <pre><code class="scala">
              def describe(e: Expr): String = (e: @unchecked) match {
              case Number(_) =&gt; "a number"
              case Var(_) =&gt; "a variable"
              // case BinOp(...				 // known from context, that never be available
              }  </code></pre>
        </div>

    </div>
    Match is an expression in Scala, i.e., it always results in a value. <br />
    Alternative expressions never “fall through” into the next case. <br />
    If none of the patterns match, an exception named MatchError is thrown.<br />
</div>


<h2>Depattering</h2>
<div>
    There are three places where pattern matching might happen: <em>val, case</em> and <em>for</em>. <em>case</em> was described above.
    <p>The patterns in <code>for</code> expressions can be used to extract values from an object providing map/flatMap/filter/withFilter/foreach functions.
    </p>
	  <pre><code class="scala">
          val exp = new BinOp("*", Number(5), Number(1))
          val BinOp(op, left, right) = exp               // extract from val, throws exception if not succeeded

          // filters for pattern, but pattern cannot be "identifier: Type", though that can be replaced by "id1 @ (id2: Type)"
          for (pattern &lt;- object providing map/flatMap/filter/withFilter/foreach) ...
      </code></pre>
</div>

<h2 id="case_seqence_as_partial_function">Case sequences as partial functions</h2>
<div>
    <h3 class="none"></h3>
    A sequence of case can be used everywhere a function literal can be used. Essentially, a case sequence is a more general function literal. Instead of having a single entry point and list of parameters, a case sequence has multiple entry points, each with their own list of parameters. Each case is an entry point to the function, and the parameters are specified with the pattern. The body of each entry point is the right-hand side of the case.
	  <pre><code class="scala">
          val withDefault: Option[Int] => Int = {
          case Some(x) => x
          case None => 0
          }	  </code></pre>

    <h4 id="Partial_functions">Partial functions</h4>
    <div>
        A sequence of cases gives a <em>partial function</em> of type <code>PartialFunction[A, R]</code>. If you apply such a function on a value it does not support, it will generate a run-time exception (<code>scala.MatchError</code>).<br />
        <p>For example, a partial function that returns the second element of a list of integers:</p>
		<pre><code class="scala">
            val second: List[Int] => Int = {
            case x :: y :: _ => y
            }	</code></pre>
        To go away from compiler warnings you need to declare that you know you are working with them, by setting proper type. <br />
        <code>(A1, A2,...,An, A)</code> is a function from <code>A1 * A2 * ... An</code> to <code>A</code>. <br />
        <code>PartialFunction[A1, A2, ..., An, A]</code> is a partial function from <code>A1 * A2 * ... An</code> to <code>A</code>.
		<pre><code class="scala">
            val second: PartialFunction[List[Int],Int] = {
            case x :: y :: _ => y
            }		</code></pre>

        Package <em>PartialFunction</em> contains couple of interesting functions which takes partial functions as an argument, to be used for matching in functional style:
        <pre><code class="scala">
            import PartialFunction._

            cond("abc") { case "def" => true }                       // result: false
            condOpt("abc") { case x if x.length == 3 => x + x }      // result: Option[java.lang.String] = Some("abcabc")
            condOpt("abc") { case x if x.length == 4 => x + x }      // result: Option[java.lang.String] = None
        </code></pre>

        <h5>Checking if a function is defined at particular value</h5>
        <div>
            They has a method <code>isDefinedAt</code> to check this.
		  <pre><code class="scala">
              second.isDefinedAt(List(5,6,7))  // returns true
              second.isDefinedAt(List())       // returns false  </code></pre>

            Other interesting method is <b><code>lift</code></b>, which will turn a <code>PartialFunction[T, R]</code> into a <code>Function[T, Option[R]]</code>, which means non-matching values will result in None instead of throwing an exception.

        </div>

    </div>
</div> <!-- case sequences as partial functions -->

<h2>Extractors</h2>
<div>
    In Scala, patterns can be defined independently of <em>case classes</em>.<br />
    Extractor is a method of which is called to see if that case can match the input.
    <p>Extractors works with <b>match</b>, <b>assignment</b> and <b>for comprehensions</b> expression.
    </p>
    Scala defines to type of extractor methods:
    <ul>
        <li>unapply(match_obj)</li>
        <li>unapplySeq(match_obj)</li>
    </ul>
    In the match phrase <code>case C(...)</code>, if C has an <code>unapply</code> then it is called with match object. The return type of <code>unapply</code> depends on the case phrase, and should be chosen as follows:
    <ul>
        <li><code>C()</code> then it is just a test, return a <code>Bollean</code></li>
        <li><code>C(param: T)</code> then return <code>Option[T]</code></li>
        <li><code>C(param_1: T1, .., param_n: Tn)</code> then return <code>Some((param_1, .., param_n)): Option[(T1, ..., Tn)]</code> - the Tuple Option</li>
        <li><code>C(param: T*)</code> then return <code>Option[Seq[T]]</code></li>
    </ul>
    <code>unapplySeq</code> is used instead <code>unapply</code> to match variable length parameters, with first on specified:
    <ul>
        <li><code>C(param_1: T, .., param_n: T, param: T*)</code> is used to match <code>unapplySeq(match_obj): Option[Seq[T]]</code></li>
    </ul>

    If the extractor returns <code>None</code> then the match is not succeed.
    <p>More about extractors on <a href="http://daily-scala.blogspot.com/2009/09/extract-sequences-unapplyseq.html">daily-scala</a></p>

		<pre><code class="scala">
            case class Food(food:String)
            case class Name(name:String)

            object Eats {
            def unapply(desc:String):Option[(Name,Food)] = {
            val i=desc.indexOf(" eats ")
            if (i> -1)
            Some((Name(desc.substring(0,i)), Food(desc.substring(i+6))))
            else None
            }
            }

            val x= "Brutus eats meat" match { case Eats(f,n) => (f,n) }   <i>// x=(Name(Brutus),Food(meat))</i>
            val Eats(f,n) = "Brutus eats meat"                            <i>// f=Name(Brutus), n=Food(meat)</i>
        </code></pre>
    <h5>For comprehensions with extractors</h5>
		<pre><code class="scala">
            val eats_l = List("A eats B", "B ate C", "C not D", "E eats F")
            for (Eats(f, n) &lt;- eats_l) yield f                   <i>// returns only List(Name("A"), Food("B"),</i>
            <i>//    other strings don't match to Eats(f,n)</i>
        </code></pre>
    <h3>Extractors versus case classes</h3>
    <div>
        TODO
    </div>
</div>
</div>



<h1>Understanding type inference algorithm</h1>
<div>
    Let's take an example code:
	<pre><code class="scala">
        def msort[T](comp: (a1: T, a2:T)=>Boolean)(List[T]) =
        ...  <i>// the body of sort method</i>

        <i>// List has build in method sortWith</i>
        <i>// using the method</i>
        1. val l = List(4,2,3)
        2. l sortWith (_ > _)                       <i> // OK </i>
        3. msort(_ > _)(l)                          <i> // ERROR </i>
        4. msort[Int](_ > _)(l)                     <i> // OK </i>
        5. msort((a1: Int, a2: Int)=> a1 > a2)(l)   <i> // OK </i>
    </code></pre>

    The problem is because virtual machine needs to known the method type to instanced it. In <code>2</code> VM knows how to instanced method sortWith because it is a part of the object, and don't has any other generic type (besides the object one)<br />
    In <code>4</code> VM knows the concrete type of msort, because we explicitly set the parametric type.<br />
    In <code>5</code> VM also knows the parametric type, VM can watch to its arguments to guess it.
    However in <code>3</code> VM can't look at the parameter <code>l</code> because msort is curried function and it is instanced step by step. So there are two calls, and the previous call needs to be instanced separately. <br />
    If we rewrite <code>msort</code> so that its parameters are swapped the code would run without error.
    <p>This inference scheme suggests the following library design principle: When designing a polymorphic method that takes some non-function arguments and a function argument, place the function argument last in a curried parameter list by its own. That way, the method's correct instance type can be inferred from the non-function arguments.
    </p>
    Example:
	<pre><code class="scala">
        val xss : List[A] = ...
        (xss :\ List[B]()) ( op )     <i>// fold right operation</i>
    </code></pre>
    Type of <code>op</code> is (A, B) => B <br />
    Here we must explicit set concrete type of List, because type of <code>op</code> is not only related to <code>xss</code>, and VM needs to instantiate properly method <code>List[A].:\ : (List[X])( (A,X) => X)</code>

    <h5>Note about limitation for type inference</h5>
    <div>
        The Interoperability with Java requires Scala’s type system compatibility with Java one. In particular, this means that Scala needs to support subtyping and (name-) overloaded definitions. This makes type inference difficult.
    </div>
</div>


<h1>Generics - type parametrization</h1>
<div>
    <h2>Constructing</h2>
    <div>
        Generic type is a type with type parameters.
        We also call <em>generic</em> trait/class as a <em>type constructor</em>, or  <em>parametrized class</em>.
        <p>We write type parameters just after type name in squared braces.</p>
			<pre><code class="scala">
                def foo[T1,T2](arg1: T1, arg2: List[T2]) = ...
                class Foo[T1,T2](arg1: T1) { ...

                <i>// specifying</i>
                val specified_foo = foo[Int, String]
            </code></pre>
        To specify the parametrized generic type we set the type parameters in squared braces. But when we use generic type, then in most cases compiler can infer the type parameters for us, so we don't need to specify it,<br />
        eg: <code>foo(1, "1"::Nil)</code>

        <h3 class="none"></h3>
        <h4>Using operator syntax</h4>
        <div>
            Generic type, which has two parameters can be specified using infix operator syntax. So two definitions below are equal:
				<pre><code class="scala">
                    val p1:  String Pair Int  = ("1", 1)
                    val p2: Pair[String, Int] = ("1", 1)
                </code></pre>
            But this syntax is quiet odd for most type names.
            <p>The situation is different if type name look like operator.<br />
                So it can be useful when we create some type alias:</p>
				<pre><code class="scala">
                    type ##[A,B] = Pair[A,B]
                    val p3:  String##Int  = ("1", 1)
                </code></pre>
        </div>

        If type is parametrized we can't make an object without parameters:
		<pre><code class="scala">
            def f(q: Queue)    <i>// Error: we need to pass a parameters to Queue</i>
        </code></pre>
    </div>

    <h2>Generics relations</h2>
    <h3>General principle in type system design</h3>
    <div>
        It is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type U is required. This is called the <em>Liskov Substitution Principle</em>.
    </div>

    <h3>Inheritance relations</h3>
    <div>
        <b>A &lt;: B</b> <span style="margin-left: 30px" /> means that A is subtype of B
    </div>

    <h3>Variance annotations</h3>
    <div>

        By default generic types are <em>nonvariant</em>. So if a value/function requires type A[T] it needs to get exactly type A[T]
        <h4>Covariant type</h4>
        <div>
            Type <code>A[]</code> is <em>covariant</em> &lt;=&gt; for each type <code>P1, P2</code> if <code>P1 &lt;: P2</code> then <code>A[P1] &lt;: A[P2]</code><br />
            We mark <em>covariant</em> type:  <code>A[+P]</code>
        </div>
        <h4>Contravariant type</h4>
        <div>
            Type <code>A[]</code> is <em>contravariant</em> &lt;=&gt; for each type <code>P1, P2</code> if <code>P1 &lt;: P2</code> then <code>A[P1] &gt;: A[P2]</code><br />
            We mark <em>covariant</em> type:  <code>A[-P]</code>

            <p>This is very important as it explains why covariance can cause some issues. Contravariance is literally the opposite of covariance: parameters vary upward with subtyping. It is a lot less common partially because it is so counter-intuitive, though it does have one very important application: functions.</p>
            <h6>Example 1</h6>
		<pre><code class="scala">
            trait Output[-T] {
            def write(x: T)
            }
        </code></pre>
            Let's have two outputs: of Seq and List.<br />
            Output is defined to be contravariant so: <code>Output[Seq] &lt;: Output[List]</code><br />
            The only supported operation by <code>Output[List]</code> is writing List to it. The same operation can be done with <code>Output[Seq]</code>. So it's safe to use <code>Output[Seq]</code> in place <code>Output[List]</code>.
            On the other hand if function expects <code>Output[Seq]</code> but gets <code>Output[List]</code> it can't perform write(some_seq). (because write expects List).

            <h6>Example 2</h6>
		<pre><code class="scala">
            trait Function1[-P, +R] {
            def apply(p: P): R
            }
        </code></pre>
            This declaration as a whole means that Function1 is contravariant in P and covariant in R. Thus, we can derive the following axioms:
		<pre><code class="scala">
            T1' &lt;: T1
            T2 &lt;: T2'
            ---------------------------------------- S-Fun
            Function1[T1, T2] &lt;: Function1[T1', T2']
        </code></pre>
            Example: <br />
            We have a functions:
		<pre><code class="scala">
            def f: Seq => String
            def g: List => AnyRef
            def F: (List => AnyRef) => AnyRef
            def F2: (Seq => String) => String
        </code></pre>
            So: <code>f &lt;: g</code> and we can pass <code>f</code> and <code>g</code> to <code>F</code>, but only <code>f</code> fits to <code>F2</code>.
            <p>What would happen if we pass <code>g</code> to <code>F2</code> ?<br />
                <code>F2</code> would call <code>g(some_seq)</code>, where g expects List and performs List specific operation on its argument - we got an error!. As an exercise one can consider return type.
            </p>
        </div>

        <h4>Sound of covariance</h4>
        <div>
            Scala's type system ensures that variance annotations are sound by keeping track of the positions where a type parameter is used.
            These positions are classified as covariant for the types of immutable fields, method results and lower bounds type parameter. Positions are classified as contravariant for method argument types and upper type parameter bounds.
            Type arguments to a non-variant type parameter are always in non-variant position.<br />
            The position flips between contra- and co-variant inside a type argument that corresponds to a contravariant parameter. The type system enforces that covariant (respectively, contravariant) type parameters are only used in covariant (contravariant) positions.
            <p>Types of mutable fields are classified as non-variant since they has corresponding setter method (which argument is the contravariant type) and and getter method (which return value is covariant type)</p>
            <p><em>private[this]</em> variables (vars and vals) are do not affect variance and don't cause problems. The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with.  For accesses to object private values this is impossible.
            </p>

        </div>
        <br />
        Example:
	  <pre><code class="scala">
          class N[T]
          class C[+T]
          class Cr[+T]
          def f1(a: N[AnyRef])
          def f2(a: C[AnyRef])          <i>// f2 accepts covariant parameters</i>
          def f3(a: Cr[Null])           <i>// f3 accepts contravariant parameters</i>

          f1(new N[String])             <i>// Error</i>
          f2(new C[String])             <i>// OK</i>
          f3(new Cr[String])            <i>// OK</i>

          <i>//hypothetical code - which don't run through covariance type violates</i>
          class Cell[T](init: T) {
          var current:T = init             <i>// error: covariant type T occurs in contravariant position</i>
          }

          val c1 = new Cell[String]("abc")
          val c2: Cell[Any] = c1
          c2.current = 1                     <i>// so far so good</i>
          val s: String = c1.current         <i>// oops! Type correct because c1 is type Cell[String] </i>
      </code></pre>
    </div>


    <h3>Escaping covariance position</h3>
    <div>
        Sometimes we want to use <em>covariance</em> types in 'other'-variant position: we want to store together values of type T and derived from T.
	  <pre><code class="scala">
          abstract class GenList[+T] { ...
          def prepend(x: T): GenList[T] =      <i>// illegal! T in contravariant position</i>
          new Cons(x, this)
          }
      </code></pre>

        With your new-found knowledge of co- and contravariance, you should be able to see why the this example will not compile - look at the covariance of class fields, and contravariance of methods arguments. <br />
        The problem is that <code>A</code> is covariant, while the <code>prepend</code> function expects its type parameter to be contravariant. Thus, <code>A</code> is varying the wrong direction. Interestingly enough, we could solve this problem by making GenList contravariant in <code>A</code>, but then the return type List[A] would be invalid as the <code>prepend</code> function expects its return type to be covariant.<br />

        Our only two options here are to a) make A invariant, losing the nice, intuitive sub-typing properties of covariance, or b) add a local type parameter to the <code>prepend</code> method which defines A as a lower bound:
        <h5>Lower bound</h5>
        <div>
			<pre><code class="scala">
                abstract class GenList[+T] { ...
                def prepend[S>:T](x: S): GenList[S] =   <i>// now is OK :) </i>
                new Cons(x, this)
                }
            </code></pre>
            As an example, suppose there is a class Fruit with two subclasses, Apple and Orange. With the new definition of class GenList, it is possible to prepend an Orange to a GenList[Apple]. The result will be a GenList[Fruit].
        </div>
    </div>

    <h3>Upper bound</h3>
    <div>
        When projecting a function, which sort lists you can find two solutions:
        <ul>
            <li>applying compare function to sort:<br />
                <code>sort[T]: (T=>Int, List[T]) => List[T]</code>
            </li>
            <li>making assumption on type parameter. Type parameter should be derived from <code>Ordered</code>, so we know the type supports &lt; &gt; ... methods<br />
                <code>sort[T &lt;: Ordered[T]]: List[T] => List[T]</code>
            </li>
        </ul>
    </div>
</div>


<h1>Abstract members</h1>
<div>
<h2>Tour of abstract members</h2>
<div>
	   <pre><code class="scala">
           trait Abstract {
           type T                        <i>// abstract type</i>
           def transform(x: T): T
           val initial: T
           var current: T
           }
       </code></pre>

    <h5>Abstract val</h5>
    <div>
        Scala can has abstract val (so we can overwrite object fields!)<br />
        An abstract val declaration resembles an abstract parameterless <em>getter</em> method declaration.
        Client is guaranteed that <em>abstract val</em> will yield <b>the same value</b> every time it is referenced. In contrast an abstract method, that guarantee would not hold, because in that case a concrete method could be implemented that returns a <b>different value</b> every time it’s called.
        <p>Any implementation of <em>val</em> must be a <em>val</em> definition (not var, def..).</p>
        <p id="abstract_val_as_parameter">Abstract vals sometimes play a role analogous to superclass parameters. This is particularly important for traits, because traits don’t have a constructor to which you could pass parameters. So parametrizing a trait works via abstract vals that are implemented in subclasses.
        </p>

        <b>CAUTION! </b>A class parameter argument is evaluated before it is passed to the class constructor (unless the parameter is by-name). An implementing val definition in a subclass, by contrast, is evaluated only after the superclass has been initialized. So the values depending of the definition of abstract val should be initialized also in subclass, or using <em>pre-initialized fields</em> or <em>lazy val</em>.

    </div>

    <h5>Abstract var</h5>
    <div>
        If you declare an abstract <em>var</em> you implicitly declare an abstract getter and setter method. There is no re-assignable field to be defined—that will come in subclasses that define the concrete implementation of the abstract var.
        <p>Concrete implementation of <em>var</em> can be <em>val, var</em> or pair of corresponding <em>def</em> getter/setter methods.</p>

    </div>

    <h5>Traits</h5>
    <div>
        Traits are by definition abstract. We can parametrize tratis through abstract fields - see <a href="#abstract_val_as_parameter">abstract vals</a>.
        <p>Traits can be instantiated by <em>anonymous class</em> that mixes in the trait. <br />
            To instantiate a trait, you need to implement the abstract definitions. Here is an example:</p>
		 <pre><code class="scala">
             trait T{
             val arg: Int
             val t = 2* arg
             }
             var x = new T { val arg=expr}      <i>// instantiation of trait T.</i>
             <i>// CAUTION!!!   x.t has inconsistent value</i>
         </code></pre>
        However there is subtle difference between class and trait initialization. The expressions which defines abstract members are evaluated as part of the initialization of the anonymous class, but the anonymous class is initialized after the trait. So the concrete values are not available during initialization of the trait - instead the selection of a them would yield the default value (like 0, "", null) <br />
        Since that in previous example, when <code>expr=2</code> then <code>x.t==0</code> which could be quiet erogenous.


    </div>

</div>
<h2>Abstract fields initialization</h2>
<div>
    As mentioned before, there is a problem with implementing <em>val</em> definition in subclass, which is evaluated only after the superclass has been initialized, and fields in superclass depends on that abstract val.

    <h3 id="pre-initialized_fields">Pre-initialized fields</h3>
    <div>
        Pre-initialized fields, lets you initialize a field of a subclass before the superclass is called.
        Because of that pre-initialized fields initializers cannot refer to the object that is being constructed (in pre-initializer: <code>val pre=this.x</code> <em>this</em> doesn't denote to object being constructed). Consequently, if such an initializer refers to <code>this</code>, the reference goes to the object containing the class or object that is being constructed, not the constructed object itself.

        <p>To make <em>pre-initialized fields</em> simply place the anonymous class definition in braces before the superclass constructor call.<br />
            Pre-initialized fields can be used in traits, objects or named subclasses.
        </p>
		<pre><code class="scala">
            trait T {
            val arg :Int
            val t=2*arg
            }

            val x1= new T { val arg=2}                    <i>// constructs anonymous class with body "val arg=2"</i>
            val x2= new { val arg=2} with T               <i>// inherits from anonymous class which body is "val arg=2" which act the PRE-INITIALIZED FIELD</i>
            object x3  extends T { val arg=2}
            object x4 extends { val arg=2} with T         <i>// object inherits from anonymous class which body is "val arg=2"</i>
            class X5 (x: Int) extends T { val arg=x }
            val x5 = new X5(2)
            class X6 (val arg: Int) extends T
            val x6 = new X6(2)
            class X7 extends T { val arg=2 }              <i>// here we implicitly inherit from AnyRef</i>
            val x7 = new X7
            class X8 extends { val arg=2 } with T         <i>// this is general rule. We inherit from anonymous class</i>
            val x8 = new X8

            x1.t        <i>//  0</i>
            x2.t        <i>//  4</i>
            x3.t        <i>//  0</i>
            x4.t        <i>//  4</i>
            x5.t        <i>//  0</i>
            x6.t        <i>//  4</i>
            x7.t        <i>//  0</i>
            x8.t        <i>//  4</i>
        </code></pre>
    </div>

    <h3>Lazy val</h3>
    <div>
        If you prefix a val definition with a <em>lazy</em> modifier, the initializing expression on the right-hand side will only be evaluated the first time the val is used. <br />
        This is similar to the situation where val is defined as a parameterless method, using a <em>def</em>. However, unlike a <em>def</em> a <em>lazy val</em> is never evaluated more than once.<br />
        So you can achieve the same what you get with <em>pre-initialized fields</em> but in more clean way.
		<pre><code class="scala">
            trait T {
            val arg :Int
            lazy val t=arg*g
            lazy val t2=arg/g
            lazy val g = {                    <i>// It is initialized before the initialization of t and t2 is completed</i>
            require(arg>0)
            1000/g
            }
            }

            val x= new T { val arg=2}           <i>// now x1.t yields correct value == 4</i>
        </code></pre>
        As we see the initialization order doesn't matter as far it doesn't produce side effects nor depends on them. <code>g</code> is initialized before <code>t</code> and <code>t2</code> because they need it when initializing.

        <h5>Objects as lazy vals</h5>
        <div>
            Objects themselves behave like lazy vals, in that they are also initialized on demand, the first time they are used. This is correct. An object definition can be seen as a shorthand for the definition of a lazy val with an anonymous class that describes the objects contents.
		  <pre><code class="scala">
              object X {
              println("hej");
              }
              <i>// as far we don't get the message "hej"</i>
              X       <i>// this is the time the message "hej" appears</i>
          </code></pre>
        </div>
    </div>
</div>

<h2 id="abstract-type-field">Abstract types</h2>
<div>
    <h3>Why we need them</h3>
    <div>
        Consider the code.
		<pre><code class="scala">
            class Food
            abstract class Animal {
            def eat(food: Food)
            }
            class Grass extends Food
            class Cow extends Animal {
            override def eat(food: Grass) {}    <i>// This won’t compile</i>
            }
        </code></pre>
        We've got: <code>error: class Cow needs to be abstract, since method eat in class Animal of type (Food)Unit is not defined<br />
        error: method eat overrides nothing...
    </code>
        What happened is that the <code>eat</code> method in class <code>Cow</code> does not override the <code>eat</code> method in class <code>Animal</code>, because its parameter type is different - it’s Grass in class Cow vs. Food in class Animal.
        <p>This behavior is justified. To see this consider the case where the previous example would be type correct. Then if we got other class <code>Fish &lt;: Food</code> we could call:</p>
	  <pre><code class="scala">
          val bessy: Animal = new Cow
          bessy eat (new Fish)                <i>// disappointment - you could feed fish to cows.</i>
      </code></pre>

        <h5>Get out</h5>
        <div>
            What if we need the abstract method with an argument type specified in a implementation classes?
	  <pre><code class="scala">
          class Food
          abstract class Animal {
          type SuitableFood &lt;: Food
          def eat(food: SuitableFood)
          }
          class Grass extends Food
          class Cow extends Animal {
          type SuitableFood = Grass
          override def eat(food: Grass) {}
          }
      </code></pre>
        </div>
    </div>

    <h3>Refinement type</h3>
    <div>
        In Scala we can refine types by supplying a base type a number of members inside curly braces. Giving previous example:
			<pre><code class="scala">
                val x = new Animal { override def eat(food: SuitableFood) {} }
            </code></pre>
        The <code>x</code> type will be <code>Animal</code>

        <h4 id="structural_types" >Structural subtyping</h4>
        <div>
            We use <em>type refinement</em> in structural subtyping.
            The difference is that <em>structural type</em> can have additional members (not only refinements one). The syntax for <em>structural type</em> is the same as for <em>refinement type</em>.
            <p>We can describe objective of <em>structural subtyping</em> as follows:<br />
                Suppose you want collect all animals which eat grass in a list. There would be to simply solutions:</p>
            <ul>
                <li>Making <code>trait GrassEaters</code> and mix it in every Animal class which SuitableFood is <code>&gt;:</code> Grass.<br />
                    <code>val List[SuitableFood] = List(...)</code> <br />
                    The downside is verbosity - you need specify SuitableFood and add dry SuitableFood trait.
                </li>
                <li>using <em>type refinement</em>: <br />
                    <code>val List[Animal { type SuitableFood = Grass} ] = List(...)</code> <br />
                    This is much cleaner solution. You don't need to remember to add GrassEaters trait, and in client's code you don't need to know about any artificial trait. Furthermore when client would like a MeatEaters, he wouldn't need to change library code.
                </li>
            </ul>
            Other example:
            <p>We want to implement <em>loan pattern</em> - a function that takes object, make some operation using this object, and clean up. We need to ensure somehow that object has some method to make clean up:</p>
				<pre><code class="scala">
                    def using[T &lt;: { def close(): Unit }, S]
                    (obj: T) (operation: T => S) = {                       <i>// curled function</i>
                    val result = operation(obj)                                   <i>// performing operation</i>
                    obj.close()                                                   <i>// cleaning up</i>
                    result                                                        <i>// return the operation result</i>
                    }

                    <i>//use case:</i>
                    using(new PrintWriter("date.txt")) { writer =>
                    writer.println(new Date)
                    }
                </code></pre>
            <b>Remark</b>. If no base type is specified, Scala uses <code>AnyRef</code> automatically.<br />
            So here type <code>T</code> is <em>structural subtype</em> of <code>AnyRef</code>

        </div>
        <h4 id="compound_types" >Compound Types</h4>
        <div>
            Suppose we want to have a method accepting argument which mixin two traits: Tr1 and Tr2.<br />
            To achieve this we can use <em>type refinement</em>
				<pre><code class="scala">
                    trait Tr1 { def method_tr1 ... }
                    trait Tr2 { def method_tr2 ... }

                    def makeTr1_Tr2(arg: Tr1 with Tr2) {
                    arg.method_tr1()
                    arg.method_tr2()
                    }
                </code></pre>
            In similar way we can also create variable with type "on the fly" supporting Tr1 and Tr2:
				<pre><code class="scala">
                    var x = new SomeClass() extends Tr1 with Tr2
                </code></pre>
        </div>
    </div>

    <h3>Path-dependent types</h3>
    <div>
        As wee see <em>types</em> can be members in Scala. We call such member <em>path-dependent types</em> and the qualified name of such type is a path to the member followed by the name of the member. <br />
        So the full properly name of SuitableFood is: <code>mypackage.bessy.SuitableFood</code>
        Lets <code>c.T</code> is an instance of a <b>path-dependent</b> type. In general, such a type has the form <code>x1 . . . . .xn .t</code>, where n > 0, <code>x1 , . . . , xn</code> denote immutable values and <code>t</code> is a type member of <code>xn</code> .
        Path-dependent types are a novel concept of Scala.

        <h4>Differences with Java inner classes</h4>
        <div>
            A path-dependent type resembles the syntax for an inner class type in Java, but there is a crucial difference: a path-dependent type names an outer object, whereas an inner class type names an outer class. Java-style inner class types can also be expressed in Scala, but they are written differently.
		  <pre><code class="scala">
              class Outer {
              class Inner
              }
              <i>// Java access:</i>
              Outer.Inner
              <i>// SCALA access:</i>
              Outer#Inner        <i>//<b> The ‘.’ syntax is reserved for objects only.</b></i>

              val o1 = new Outer
              val o2 = new Outer
          </code></pre>

            <code>o1.Inner, o2.Inner</code> are two different path-dependent types.<br />
            <code>Outer#Inner</code> is a general type, which represents the Inner class with an arbitrary outer object of type Outer.<br />
            By contrast, type <code>o1.Inner</code> refers to the Inner class with a specific outer object (the one referenced from o1).

            <h5 id="instantiating_inner_classes">Instantiating inner classes</h5>
            In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance. This allows an inner class to access members of its outer class.
            Thus you <b>can’t instantiate an inner class without specifying an outer class instance</b>.<br />
            One way to do this is to instantiate the inner class inside the body of the outer class. In this case, the current outer class instance (referenced from <em>this</em>) will be used.<br />
            Another way is to use a path-dependent type. For example, because the type, o1.Inner, names a specific outer object, you can instantiate it: <code>new o1.Inner</code> . The resulting inner object will contain a reference to its outer object, the object referenced from <code>o1</code>.<br />
            By contrast, because the type <code>Outer#Inner</code> does not name any specific instance of Outer, you can’t create an instance of it: <code> new Outer#Inner   <i>// Error</i></code>


        </div>

        <h4>Path prefix immutability</h4>
        <div>
            Path-dependent types rely on the immutability of the prefix path. Here is an example where this immutability is violated.
	<pre><code class="scala">
        abstract class AbsCell {
        type T
        val init: T
        private var value: T = init
        def get: T = value
        def set(x: T): unit = { value = x }
        }

        var flip = false
        def f(): AbsCell = {
        flip = !flip
        if (flip) new AbsCell { type T = int; val init = 1 }
        else new AbsCell { type T = String; val init = "" }
        }
        f().set(f().get)                      <i>// illegal!</i>
    </code></pre>

            <code>f()</code> return cells where the value type is alternating <code>Int</code> and <code>String</code>. <br />
            The last statement in the code above is erroneous since it tries to set an <code>int</code> cell to a <code>String</code> value. The type system does
            not admit this statement, because the computed type of <code>f().get</code> would be <code>f().T</code>. This type is not well-formed, since the method call f() is not a path (doesn't denote immutable value).

        </div>
    </div>

    <h3>Lambda types</h3>
    <div>
        Suppose we have a generic type parametrized by other generic type:<br />
        <code>trait Functor[F[_]]</code> - some container type supporting fmap operation.
        <p>
            How we could create Functor type parametrized by type having three type parameters, eg <code>Function2[A, B, R]</code>?
        </p>
        <p>The solution is to bind all by one type parameters in a structural type:</p>
			<pre><code class="scala">
                implicit def Function2Functor[A, B] = new Functor[({type λ[R]=(A, B) => R})#λ] {
                <i>// definition of abstract method</i>
                }
            </code></pre>
        Here we create implicit function which gives us implicit object of <code>Functor[(A, B) => R]</code>.<br />
        We bind A and B types in structural type <code>{type λ[R]= (A,B) => R}</code> which has one field type parametrized by one type parameter.<br />
        Then we extract the field type to get what we want.<br />
        The syntax presented above is called <b>Lambda type</b>.
        <p>
            We couldn't write <code>new Functor[(A, B =>R)]</code> because type (A, B)=>R is not type constructor - it doesn't take any type parameter. The type is already constructed by Function2[_,_,_]
        </p>
        <p>
            <code>Function2[_,_,_]</code> is generic type, but it takes 3 parameters. We expect that Functor takes type which is parametrized only by one type (one parameter type constructor).
        </p>
    </div>
</div>

<h2>Enumerations</h2>
<div>
    Scala don't need build in language constructs for enumerations. Instead it uses language features to get them.
    <p>To create a new enumeration, you define an object that extends <code>scala.Enumeration</code> class, as in the following example:</p>
		<pre><code class="scala">
            object Color extends Enumeration {
            val Red, Green, Blue = Value
            }

            object Direction extends Enumeration {
            val North = Value("North")           <i>// overloaded Value function with takes `name` argument</i>
            }
        </code></pre>
    Enumeration defines an inner class named <code>Value</code>, and the same-named parameterless <code>Value</code> method returns a fresh instance of that class. This means that a value such as <em>Color.Red</em> is of type <em>Color.Value</em> which is a <em>path-dependent type</em>, with Color being the path and Value being the dependent type.
    <p>Values of an enumeration are numbered from 0, and you can find them out by its id method:<br />
        <code>Direction.North.id</code>
    </p>
    <p>It’s also possible to go the other way, from a non-negative integer number to the value that has this number as id in an enumeration:<br/>
        <code>Direction(0)</code>
    </p>


</div>

</div><!-- Abstract types -->


<h1>Implicits</h1>
<div>
<h2>Implicit functions</h2>
<div>
    We define implicit function by prefix function definition with <code>implicit</code> keyword, eg:
		  <pre><code class="scala">
              implicit def intToX(i: Int) = new X(i)
          </code></pre>
    When such function is directly in scope (accessed without any preceding identifier), we can implicit convert variable Int to X (for example when function expects X, but we pass Int)
</div>

<h2>Implicit conversions</h2>
<div>
    Implicit conversions are made by implicit functions.<br />
    Implicit definitions are made by prepending <em>implicit</em> keyword before normal definition.
    <p>Implicit definitions are used by compiler to insert into a program in order to fix any of its type errors. <br />
        For example, if <code>x + y</code> does not type check, then the compiler might change it to <code>convert(x) + y</code>, where convert is some available implicit function. If convert changes x into something that has a + method, then this change might fix a program so that it type checks and runs correctly. If convert really is just a simple conversion function, then leaving it out of the source code can be a clarification.
    </p>
    <h5>When Compiler can use implicit conversions</h5>
    <ul>
        <li>Scope Rule: is in the scope as a single identifier, or is associated (in companion object) with the source or target type of the conversion.<br />
            So the function must be in the current scope, must be imported as a single name, or must be in companion object of the  source/target type</li>
        <li>Only one available Rule<br />
            There will be compile time error when there are to implicit conversions available to use - because this make ambiguous.<br />
            There is exception to this rule if one of the available conversions is strictly <em>more specific</em> than the others, then the compiler will choose the more specific one
        </li>
        <li>One-at-a-time Rule: only one implicit is tried<br />
            So implicit conversions can't be composed (eg: f(g(x)) )</li>
        <li>Explicits - First Rule: Whenever code type checks as it is written, no implicits are attempted. The compiler will not change code that already<br />
            A corollary of this rule is that you can always replace implicit identifiers by explicit ones, thus making the code longer but with less apparent ambiguity. You can trade between these choices on a case-by-case basis. </li>
    </ul>

    <h5>When more conversions are available</h5>
    <div>
        According to <em>Only one available Rule</em> compiler will allow to exist more then one conversion available (in the same scope) only when one of them is strictly more specific then others.<br />
        One implicit conversion is more specific than another if one of the following applies:
        <ul>
            <li>The argument type of the former is a subtype of the latter’s.</li>
            <li>Both conversions are methods, and the enclosing class of the former extends the enclosing class of the latter.</li>
        </ul>

        So if there are two functions: <code>f1: List[Int] => String; f2: Seq[Int] => String</code> and compiler expects String, but gets List[Int], then it will choose <code>f1</code> function.<br />
        The consequence of the second point is that in <code>"abc".reverse</code> compiler will choose conversion from String to <code>StringOps &lt;: SeqLike[Char]</code> instead of <code>WrappedString &lt;: SeqLike[Char]</code> (the old one from Scala 2.7) because the former is declared in <code>Scala.Predef</code>, the letter one in <code>Scala.LowPriorityImplicits</code> and <code>Predef &lt;: LowPriorityImplicits</code>

    </div>

    <h5>Where implicit are tried</h5>
    <ul>
        <li>conversions to an expected type</li>
        <li>conversions of the receiver of a selection</li>
        <li>implicit parameters</li>
    </ul>

    <code>Scala.Predef</code> contains numerous of helpful implicit conversions.

    <h5>How to check which implicit were chosen</h5>
    <div>
        when compiling type:
        <blockquote>scala(c)  -Xprint:typer</blockquote>
        It will  show you what your code looks like after all implicit conversions  have been added by the type checker.
    </div>

</div>

<h2>Converting the receiver</h2>
<div>
    This kind of implicit conversion has two main uses.
    <ul>
        <li>allow smoother integration of a new class into an existing class hierarchy.</li>
        <li>they support writing domain-specific languages (DSLs) within the language.</li>
    </ul>
    To see how it works, suppose you write down <code>obj.doIt</code>, and obj does not have a member named <code>doIt</code>. The compiler will try to insert conversions before giving up. In this case, the conversion needs to apply to the receiver, <code>obj</code>. The compiler will act as if the expected "type" of <code>obj</code> were "has a member named doIt." This "has a doIt" type is not a normal Scala type, but it is there conceptually and is for compiler to insert an implicit conversion in this case.

    <h3>Interoperating with new types</h3>
    <div>
			<pre><code class="scala">
                class Rational(n: Int, d: Int) {
                ...
                def + (that: Rational): Rational = ...
                def + (that: Int): Rational = ...
                }
                <i>// so we can add either two rational numbers or rational and int</i>
                val r = new Rational(1,2)
                1 + r                        <i>// error, Int doesn't have method +(x: Rational)</i>
                implicit def intToRational(x: Int) = new Rational(x, 1)
                1 + r                        <i>// now we can add int to rational</i>
            </code></pre>
    </div>

    <h3>Simulating new syntax</h3>
    <div>
        <code>-></code> in <code>1 -> "one"</code> is not a syntax! Instead, <code>-></code> is a method of the class <code>ArrowAssoc</code>, a class defined inside the standard Scala. It also contains implicit conversion from Any type to <code> ArrowAssoc</code>.<br />
        Here the compiler inserts the implicit conversions form 1 to <code>ArrowAssoc</code>
    </div>
</div>


<h2>Implicit parameters</h2>
<div>
    Implicit  parameter is variable, or an object which is missing, within function arguments list - so compiler can replace <code>someCall(a)</code> with <code>someCall(a)(b)</code> or <code>new SomeClass(a)</code> with <code>new SomeClass(a)(b)</code>.
    <p>Implicit parameter can be the <b>entire last curried parameter list</b> that’s supplied, not just the last parameter.
    </p>
    <p>To let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which is <b>marked</b> with <em>implicit</em> keyword.
    </p>
    <p>implicit keyword applies to an entire parameter list, not to individual parameters.
    </p>

			<pre><code class="scala">
                class PreferredPrompt(val preference: String)
                object Greeter {
                def greet(name: String)(implicit prompt: PreferredPrompt, drink: String) {
                println("Welcome, "+ name +". The system is ready.")
                println("why not enjoy a cup of "+ drink +"?")
                println(prompt.preference)
                }
                }

                implicit val bobsPrompt = new PreferredPrompt("relax> ")        <i>// it must be marked implicit if compiler might use it</i>
                //implicit object BobsPrompt extends PreferredPrompt("relax> ") <i>// Other way to achieve the same as the previous statement</i>
                implicit val bobsDrink = "Coca-Cola"
                Greeter.greet("Bob")(bobsPrompt)                                <i>// error: not enough arguments...</i>
                Greeter.greet("Bob")                                            <i>// compiler convert it to Greeter.greet("Bob")(bobsPrompt, bobsDrink)</i>
            </code></pre>

    You need to be careful which variables you make implicit. It is wise to not select popular types for implicit, instead choose some rare types (as PreferredPrompt). As a result, it is unlikely that implicit variables of these types will be in scope if they are not intended to be used as implicit parameters.
</div>


<h2>Type bound</h2>
<div>
    Firstly check some interesting implicit related functions:
    <ul>
        <li><code>class &lt;:&lt;</code> in <code>Predef</code> - an instance of that class witnesses that A is a subtype of B.<br />
            <code>A &lt;:&lt; B</code> encodes to the constraint <code>A &lt;: B</code></li>
        <li><code>def &lt;:&lt;</code> in <code>Manifest</code> - it checks whether the type represented by this manifest is a subtype of that represented by the manifest argument.
        </li>
        <li><code>class T1=:=T2</code> - asserts that T1 and T2 are the same type. (does not admits subclassing as <code>&lt;:&lt;</code> )</li>
        <li><code>def implicitly[T](implicit e: T): T = e</code> - a function which doesn't take any argument, and returns implicit value/function of type <code>T</code> -  the one which compiler would take if it needs</li>
        <li><code>def context[C[_], T](implicit e: C[T]) = e</code> - this allow us get an implicit value type C[T] by simply writing "context.some_ct_method" </li>
        <li>information about taking implicit values: <a href="http://stackoverflow.com/questions/4373070/how-do-i-get-an-instance-of-the-type-class-associated-with-a-context-bound/">here</a></li>
    </ul>

    <h3 id="view_bound">View bound</h3>
    <div>
        Consider function <a href="#implicit_maxListElem">maxListElem</a> example. In the body of <code>maxListElem</code> we don't use explicitly <code>ordered</code> function. So the code will be proper if we change the argument name from ordered to anything else.<br />
        Because this pattern is common, Scala lets you leave out the name of this parameter and shorten the method header by using a <em>view bound</em>.
        <p>View bound are made by putting <b>&lt;%</b> in type parameters declaration:</p>
			  <pre><code class="scala">
                  def maxList[T &lt;% Ordered[T]](elements: List[T]): T = ...

                  <i>// which compiles to:</i>
                  def maxList[T](elements: List[T])(implicit ev: T=>Ordered[T]): T = ...
              </code></pre>
        <b>T &lt;% Ordered[T]</b> means  "I can use T, as long as T can be treated as an Ordered[T]."<br />
        For example, class <code>Int</code> is not a subtype of <code>Ordered[Int]</code>, but you can pass a <code>List[Int]</code> to maxList because an implicit conversion from Int to Ordered[Int] is available.<br />
        Moreover, if type <code>T</code> happens to already be an <code>Ordered[T]</code>, you can still pass a List[T] to maxList. The compiler will use an implicit <code>identity[T]</code> function, declared in Predef.

        <h4 id="view_bound_application">What are applications for view bounds</h4>
        <div>
            <b id="pimp_my_library">pimp my library pattern</b> - a way to "add" methods to existing classes, and return original type. <br />
            Eg: we want to use rich functionality from Scala string - <code>StringOps</code> but working on original <code>String</code>.<br />
            Eg2:
				<pre><code class="scala">
                    def f[A &lt;% Ordered[A]](xs: A*): Seq[A] = xs.toSeq.sorted

                    <i>// even if the type is only used as a type parameter of the return type</i>
                    def f[A &lt;: Ordered[A]](xs: A*): Seq[A] = xs.toSeq.sorted   <i>// oops, not every type supported </i>
                    def f[A](xs: Ordered[A]*): Seq[A] = xs.toSeq               <i>// implicit conversion to an expected type occurs,</i>
                    <i>// return type is Seq[Ordered[A]]</i>
                </code></pre>
            This example won't work without view bounds. However, if I were to return another type, then I don't need a view bound any more:
				<pre><code class="scala">
                    def f[A](a: Ordered[A], b: A): Boolean = a &lt; b
                </code></pre>
            Eg3. Handling String and Array, which are Java classes, like they were Scala collections:
				<pre><code class="scala">
                    def handle_collection[CC &lt;% Traversable[_]](a: CC, b: CC): CC =
                    if (a.size &lt; b.size) a else b
                </code></pre>
            If one tried to make <code>handle_collection</code> without view bounds, the return type of a String would be a WrappedString (Scala 2.8), and similarly for Array.
        </div>
    </div>

    <h3>Context bound</h3>
    <div>
        We write context bound:
			  <pre><code class="scala">
                  def context_fun[T : P](a: T) = ...

                  <i>// which compiles to:</i>
                  def context_fun[T : P](a: T)(implicit v: P[T]) = ...
              </code></pre>
        Context are used to make assure that there exists some implicit value of parametrized type <code>P[T]</code><br />
        We can say: "For value for type T ensure existence of implicit value `x` in context P. x type is P[T]".
        <p>The common example of usage in Scala is this:</p>
			  <pre><code class="scala">
                  def f_context_ord[A : Ordering](a: A, b: A) = implicitly[Ordering[A]].compare(a, b)
              </code></pre>
        f_context_ord require some implicit Ordering[A] class instance to compare a and b.

        <h4>Context Bounds generalize View Bounds.</h4>
        <div>
				<pre><code class="scala">
                    def f1[T &lt;% String](t: T) = 0

                    <i>// equivalent with context bound</i>
                    trait To[T] { type From[F] = F => T }
                    def f2[T : To[String]#From](t: T) = 0
                </code></pre>
            A context bound must be used with a type constructor of kind * =&gt; * (a `function` to get implicit value gets type T and results implicit value of context type C[T]). However the type constructor for Function1 is of kind (*, *) =&gt; * (type constructor gets two types: function argument type, and function result type; and results implicit function). The use of the type alias partially applies second type parameter with the type String, yielding a type constructor of the correct kind for use as a context bound.

            <p>There is a proposal to allow you to directly express partially applied types in Scala, without the use of the type alias inside a trait. You could then write:</p>
				<pre><code class="scala">
                    def f3[T : [X](X => String)](t: T) = 0
                </code></pre>
        </div>


        <h4>Constructing Arrays</h4>
        <div>
            An Array initialization on a parametrized type requires a ClassManifest[A] to be available, for arcane reasons related to type erasure and the non-erasure nature of arrays.
				<pre><code class="scala">
                    def f1[A](n: Int) = new Array[A](n)                   <i>// error: cannot find class manifest for element type T</i>
                    def f1[A : ClassManifest](n: Int) = new Array[A](n)
                </code></pre>
        </div>

        Examples:
			  <pre><code class="scala">
                  def **[T : Numeric](xs: Iterable[T], ys: Iterable[T]) =
                  xs zip ys map { t => implicitly[Numeric[T]].times(t._1, t._2) }   <i>// We get implicit context value through implicitly function</i>
                  def **[T : Numeric](xs: Iterable[T], ys: Iterable[T]) =
                  xs zip ys map { t => context[T]().times(t._1, t._2) }              <i>// the same as above, but we use context function</i>
              </code></pre>

        <h4>What are applications for context bounds</h4>
        <div>
            <b id="typeclass">typeclass pattern</b> - implements an alternative to inheritance  by grouping many different types that share a common set of methods, just like a superclass can be used to group its subclasses.<br />
            Grouping is make through a sort of implicit adapter pattern. More about <a href="#using_typeclass">using typeclass pattern</a>
            <p>The classic example is Scala 2.8's <code>Ordering</code>, which replaced <code>Ordered</code> throughout Scala's library and take advantage of some implicit conversions inside Ordering that enable the traditional operator style. Another example in Scala 2.8 is the Numeric:
            </p>
				<pre><code class="scala">
                    def f[A](a: A, b: A)(implicit ord: Ordering[A]) = {
                    import ord._                                        <i>// import members from implicit value ord</i>
                    if (a &lt; b) a else b                                 <i>// you can call explicitly ord.lt(a,b)</i>
                    }

                    def f[A : Numeric](a: A, b: A) = implicitly[Numeric[A]].plus(a, b)
                </code></pre>
            A more complex example is the new collection usage of <code>CanBuildFrom</code>. And, as mentioned before, there's the <code>ClassManifest</code> usage, which is required to initialize new arrays without concrete types.

            <p>The context bound with the typeclass pattern is much more likely to be used by your own classes, as they enable separation of concerns, whereas view bounds can be avoided in your own code by good design (it is used mostly to get around someone else design).</p>

            <p>Though it has been possible for a long time, the use of context bounds has really taken off in 2010, and is now found to some degree in most of Scala's most important libraries and frameworks. The most extreme example of its usage, though, is the Scalaz library, which brings a lot of the power of Haskell to Scala. I recommend reading up on typeclass patterns to get more acquainted it all the ways in which it can be used.</p>
        </div>
    </div>
    <hr />
    The manual data for implicit are made with some StackOverflow answers help:
    <ul>
        <li><a href="http://stackoverflow.com/questions/4465948/what-are-scala-context-and-view-bounds/4467012#4467012">What are Scala context and view bounds?</a></li>
        <li><a href="http://stackoverflow.com/questions/2982276/what-is-a-context-bound-in-scala">What is a “context bound” in Scala?</a></li>
        <li><a href="http://stackoverflow.com/questions/5332801/how-can-i-chain-implicits-in-scala">How can I chain implicits in Scala?</a></li>
        <li><a href="http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits">Where does Scala look for implicits?</a></li>
    </ul>
</div>


<h2>Common patterns with implicits</h2>
<div>
<h3>Function composition</h3>
<div>
    Function composition is not so flexible as in Haskell since Scala functions are not curried by default.
    So mostly we need to round about partially applied functions.
    <p>Scala functions (class FunctionX) has a 2 methods <code>andThen, compose</code> which performs composition. f andThen g = g(f), f compose g = f(g)</p>

    <h6>Using Scalaz</h6>
    Good solution is to use Scalaz <code> &amp;&amp;&amp; </code> operator.

</div>


<h3 id="implicit_providing_more_inf">Providing more information</h3>
<div>
    Consider the function which finds the maximum element in the given list:
			<pre><code class="scala">
                def maxListElem[T &lt;: Ordered[T]](elements: List[T]): T =
                ...
                }
            </code></pre>
    Everything would go fine, but many popular buildin types are not subtype of <code>Ordered[]</code> (like <code>Int, String</code>...).<br />
    Many buildin types has implicit methods which converts them to popular traits, like <code>Ordered</code>.<br />
    The solution would be to add additional information to type <code>T</code> - how to convert it to type <code>Ordered[T]</code>
			<pre id="implicit_maxListElem"><code>
                def maxListElem[T](elements: List[T])
                (implicit orderer: T => Ordered[T]): T =
                elements match {
                case List() =>
                throw new IllegalArgumentException("empty list!")
                case List(x) => x
                case x :: rest =>
                val maxRest = maxListElem(rest)(orderer)        <i>// implicit put (ordered) - maxListElem(rest)(ordered)</i>
                if (x > maxRest) x                              <i>// implicit call ordered(x) when type x don't have &gt; method</i>
                else maxRest
                }

                implicit def myTypeToOrdered(x: MyType): = new Ordered[MyType] {
                def compare(that: MyType) = x.some_field - that.some_field;
                }
            </code></pre>
    Now we can use function <code>maxListElem</code> with <code>List[MyType]</code>
</div>


<h3>Trait replacement</h3>
<div>
    To ensure that some class has some functionality we can use below solution then mixing Traits:
			  <pre><code class="scala">
                  <i>// with view -- implicit function</i>
                  abstract class MyType (implicit cmp : MyType => Ordered[MyType]) {
                  ...
                  }
                  implicit def MyTypeToOrdered(x: MyType) = new MyType Ordered[MyType] {
                  def compare ...
                  }
                  <i>// or with context bound:</i>
                  abstract class MyType (implicit ev : Ordering[MyType]) {
                  ...
                  }
                  implicit val MyTypeToOrdering = new Ordering[MyType]{
                  def compare(a: MyType, b: MyType) = ...
                  }

                  <i>// Instead of: </i>
                  abstract class MyType with Ordered[K] {


                  <i>// other use case for class parameter</i>
                  abstract class RedBlackTree[K, V] (implicit cmp : K => Ordered[K]) ...   <i>// equally [K &lt;% Ordered, V], but we can use directly cmp method </i>
              </code></pre>
    The benefits of such solution are described in other parts of this subsection:
    <ul>
        <li><a href="#ordered_vs_ordering">ordered vs ordering</a></li>
        <li><a href="#view_bound_application">view bound application</a></li>
    </ul>


</div>


<h3>Conditional type extend</h3>
<div>
    Consider example:<br />
    We have an abstract class with an type field.<br />
    We want to compare those subclasses which has the same value of type member.<br />
    This is problematic to make this on type level with traits, without throwing exception when objects doesn't have the same type field.<br />
    But implicit values makes here a good job.
				<pre><code class="scala">
                    abstract class A{
                    type B
                    }
                    <i>// We want to make compare instance of classes C1 &lt; A and C2 &lt; A only when C1#B = C2#B</i>

                    type AA[T] = A { type B = T }           <i>// type alias for A in generic form</i>

                    implicit def aIsOrdered[T](a : AA[T]) = new Ordered[AA[T]] {
                    def compare(that : AA[T]) = ...
                    }
                </code></pre>
    Now we can put the list of A subtypes, which have the same <code>type B</code> field, to some requires Ordered view, as well Ordering context.
</div>


<h3>Rich methods as implicit functions</h3>
<div>
    Let's take another example:<br />
    We want to make some DSL for regular expressions. There will base type to represent RegExp family, and <em>implicit</em> function for conversion from <code>String</code> to <code>Str</code> type - which is simple regexp matching exactly this string.
				<pre><code class="scala">
                    abstract class RegExp {
                    def nullable: Boolean
                    def derive(c: Char): RegExp
                    def match(s: String) =
                    if (s.isEmpty) nullable
                    else derive(s.head).match(s.tail)
                    }

                    case object Empty extends RegExp {
                    def nullable = false
                    def derive(c: Char) = Empty
                    }

                    case object Eps extends RegExp {
                    def nullable = true
                    def derive(c: Char) = Empty
                    }

                    case class Str(s: String) extends RegExp {
                    def nullable = s.isEmpty
                    def derive(c: Char) =
                    if (s.isEmpty || s.head != c) Empty
                    else Str(s.tail)
                    }

                    case class Cat(r: RegExp, s: RegExp) extends RegExp {
                    def nullable = r.nullable && s.nullable
                    def derive(c: Char) =
                    if (r.nullable) Or(Cat(r.derive(c), s), s.derive(c))
                    else Cat(r.derive(c), s)
                    }

                    case class Star(r: RegExp) extends RegExp {
                    def nullable = true
                    def derive(c: Char) = Cat(r.derive(c), this)
                    }

                    case class Or(r: RegExp, s: RegExp) extends RegExp {
                    def nullable = r.nullable || s.nullable
                    def derive(c: Char) = Or(r.derive(c), s.derive(c))
                    }

                    case class And(r: RegExp, s: RegExp) extends RegExp {
                    def nullable = r.nullable && s.nullable
                    def derive(c: Char) = And(r.derive(c), s.derive(c))
                    }

                    <i>// repetitions, eg "Rep("a", 4)" matches "aaaa"</i>
                    case class Rep(r: RegExp, n: Int) extend RegExp {
                    def nullable = r.nullable
                    def derive(c: Char) = repr.derive(c)
                    def repr =
                    val aux = (i:Int) =>
                    if (n&lt;=0) r
                    else      Cat(r, aux(n-1))
                    aux(n)
                    <i>// Other possibility to represent Repr is to move <b>repr</b> function to some object</i>
                    }

                    case class Not(r: RegExp) extends RegExp {
                    def nullable = !r.nullable
                    def derive(c: Char) = Not(r.derive(c))
                    }
                </code></pre>
    <p>We can construct regular expressions (for example to match simple string "start" or "end") using:</p>
    <ul>
        <li>constructor composition, eg: <code>Or(Str("start"), Str("end"))</code></li>
        <li>operators, eg: <code>Str("start") | Str("end")</code></li>
    </ul>
    Operators support we can achieve by:
    <ul>
        <li>entering operators in base class as a methods. I assume that this is known how to make it</li>
        <li>making implicit conversion to some <em>structural subtype</em> which contains methods to operate on RegExp:
					<pre><code class="scala">
                        object RegExpPimps {
                        implicit def string2RegExp(s: String) = Str(s)

                        implicit def regExpOps(r: RegExp) = new {
                        def | (s: RegExp) = Or(r, s)
                        def & (s: RegExp) = And(r, s)
                        def % = Star(r)
                        def %(n: Int) = rep(r, n)
                        def ? = Or(Eps, r)
                        def ! = Not(r)
                        def ++ (s: RegExp) = Cat(r, s)
                        def ~ (s: String) = Matcher.matches(r, s)
                        }

                        implicit def stringOps(s: String) = new {
                        def | (r: RegExp) = Or(s, r)
                        def | (r: String) = Or(s, r)
                        def & (r: RegExp) = And(s, r)
                        def & (r: String) = And(s, r)
                        def % = Star(s)
                        def % (n: Int) = rep(Str(s), n)
                        def ? = Or(Eps, s)
                        def ! = Not(s)
                        def ++ (r: RegExp) = Cat(s, r)
                        def ++ (r: String) = Cat(s, r)

                        def ~ (t: String) = string2RegExp(s).match(t)
                        }
                    </code></pre>
        </li>
    </ul>
    We can use this as following:<br />
    In the main function we construct some regular expressions, and in then we try to test them

				<pre><code class="scala">
                    object Test {
                    def main(args: Array[String]) {

                    <i>// we start from opening RegExpPimps object content, to get access to implicit functions</i>
                    <i>//     and to implicit conversion from String to RegExp</i>
                    import RegExpPimps._

                    <i> // here we construct some regular expressions</i>
                    val digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
                    val int = ("+" | "-").? ++ digit.%(1)
                    val real = ("+" | "-").? ++ digit.%(1) ++ ("." ++ digit.%(1)).? ++ (("e" | "E") ++ ("+" | "-").? ++ digit.%(1)).?

                    <i>// Some strings to test regular expressions</i>
                    val ints = List("0", "-4534", "+049", "99")
                    val reals = List("0.9", "-12.8", "+91.0", "9e12", "+9.21E-12", "-512E+01")
                    val errs = List("", "-", "+", "+-1", "-+2", "2-")

                    <i>// testing</i>
                    <i>// <b>~</b> calls match function</i>
                    ints.foreach(s => assert(int ~ s))
                    reals.foreach(s => assert(!(int ~ s)))
                    errs.foreach(s => assert(!(int ~ s)))

                    ints.foreach(s => assert(real ~ s))
                    reals.foreach(s => assert(real ~ s))
                    errs.foreach(s => assert(!(real ~ s)))
                    }
                </code></pre>

    The difference between <em>rich methods</em> and base class support is: we have access to methods only when we import implicit functions.<br />
    So, if in some part of code we have implicit conversions to 2 or more objects supported by <em>rich methods</em> <u>we can choose</u> which one we want to use by precisely importing them.
</div>

<h3 id="using_typeclass" ><a href="#typeclass">Typeclasses</a> - implicit objects against polymorphism with traits</h3>
<div>
    <h5>Only one definition of trait problem</h5>
    When mixin trait we stand on one definition of feature which trait declares.
    <p>When using <em>typeclasses</em> we benefit multiple feature definitions. We just import that typeclass we want, and we are ok with other feature interpretation.</p>
    We can achieve the same with traits by <a href="#structural_types">structural subtyping</a>, but it doesn't looks nice when we need to mixin some other functionality and overwrite the default one in some context.
			<pre><code class="scala">
                <i>// mixin trait way</i>
                trait FeatureX = { def makeX : Int; }
                class A extends FeatureX = {
                def makeX = { <i>// default makeX interpretation</i>
                }
                }
                val a = new A
                val a2 = new A {
                def makeX = { <i>// other makeX interpretation</i>
                }
                }
                val a3 = new A extends SomeTraitWithFeatureX    <i>// a3 with arbitrary makeX interpretation from SomeTraitWithFeatureX</i>

                <i>// typeclass way</i>
                class A
                trait FeatureX[T] = { def makeX(t : T) : Int; }
                implicit a1_WithFeatureX = new FeatureX[A] {
                def makeX{ <i>// first makeX interpretation</i>
                }
                }
                implicit a2_WithFeatureX = new FeatureX[A] {
                def makeX{ <i>// second makeX interpretation</i>
                }
                }

                import SomeImplicits.a3_WithFeatureX      <i>// other implicit object with arbitrary makeX for type A interpretation</i>
            </code></pre>

    <h5>Only one parametrized trait problem</h5>
    Other problems with mixins is when we rely on some type to be useful in multiple version of some parametrized trait.<br />
    Consider the example:
			<pre><code class="scala">
                case class X(x: Int) extends Ordered[X] {
                def compare(other: X) = x - other.x
                }

                def binSearch[A &lt;% Ordered[A]](a: Array[A], v: A){
                def recurse(low: Int, high: Int): Option[Int] = (low + high) / 2 match {
                case _ if high &lt; low => None
                case mid if a(mid) > v => recurse(low, mid - 1)
                case mid if a(mid) &lt; v => recurse(mid + 1, high)
                case mid => Some(mid)
                }
                recurse(0, a.size - 1)
                }

                binSearch(Array(X(1), X(2)), X(2))
                binSearch(Array(X(1), X(2)), 2)                          <i>// Type error</i>
            </code></pre>
    We would like to see <code>X</code> as both <code>Ordered[X], Ordered[Int]</code>. But we don't want to see <code>Int</code> as <code>X</code>.<br />
    One could think to make additional mixin:
			<pre><code class="scala">
                case class X(x: Int) extends Ordered[X] with Ordered[Int] ...       <i>// <b>Illegal!</b></i>
            </code></pre>
    But this is impossible due to <em>type erasure</em>. After type erasure both Ordered[Int] and Ordered[X] are seen as the same parametrized class, so it makes disambiguation and compiler doesn't allow this.<br />
    One good solution is to use more elaborated implicit conversions:
			<pre><code class="scala">
                def binarySearch[B, A &lt;% Ordered[B]](a: Array[A], v: B) =  ...
                <i>// implicit conversion from X to Ordered[X] exists - it is identity</i>
                <i>// we need to make implicit conversion from X to Ordered[Int] to search for int</i>

                implicit val compThingToInt: Thing => Ordered[Int] =
                t => new Ordered[Int] {
                def compare(that: Int): Int = { t.n - that }
                }
            </code></pre>
    Other solution might be to use <em>typeclasses</em>
    <br /><br />

    More information about this problem and some solution can be found <a href="http://jim-mcbeath.blogspot.com/2010/05/my-misperception-of-scalas-ordered.html#c3281053727778607031">here</a>. Very interesting is the first comment.


    <h4 id="ordered_vs_ordering">Ordered vs Ordering</h4>
    <div>
        <code>Ordered[T]</code> is a trait, which we use to compare <code>T</code> values by mixin with type <code>T</code>.<br />
        When we want to auto-create compare-like methods with other types we need to make some trick:
			  <pre><code class="scala">
                  <i>// The BAD!!! code - it hacks the type system, and can make some bad work in the future (Read above subsection)</i>
                  case class Thing(val n:Int) extends Ordered[Any] {
                  def compare(that: Any): Int = that match {
                  case i:Int => this.n - i
                  case x:Thing => this.n - x.n
                  case _ => throw new IllegalArgumentException("bad type")
                  }
                  }
                  <i>// Better solution is to use something from the upper subsection</i>
                  <i>//   - the normal compare method (which takes Thing argument) and add additional implicit methods</i>
              </code></pre>
        Otherwise we need to implement dozones of compare-like methods (&gt;, &gt;= ...).

        <p><code>Ordering[T]</code> is a trait - <em>typeclass</em>, which we use to compare <code>T</code> values by creating (or importing) implicit object of type <code>Ordering[T]</code> with appropriate methods definitions.</p>

        <p>Ordering has more function to work with. eg: <code>reverse</code> which returns reverse ordering of some type. The working with reverse requires to explicitly apply the Ordering instance to method call:</p>
				<pre><code class="scala">
                    <i>// TreeMap requires Ordering context</i>
                    <i>// assuming we have some Ordering[Foo]</i>
                    new TreeMap[Foo, Bar]()(implicitly[Ordering[Foo]].reverse)
                </code></pre>

        <p>Ordered is being deprecated in favor of Ordering. Ordering is strictly more powerful because you can have several Orderings on a class Foo, whereas Foo can only implement Ordered once. (You can fake with by having Foo -not- implement Ordered, and making several implicit conversions to Ordered[Foo], and controlling the scope of those implicits, but this is kind of hack and also performs very poorly.)</p>

        Thanks to the implicit definitions in <code>scala.math.LowPriorityOrderingImplicits</code> Ordered types, or types which have implicit conversion to Ordered type, are sufficient to provide us with corresponding Ordering type class instances.
    </div>

    <h4 id="narrowing_types">Narrowing argument types</h4>
    <div>
        This present something similar to <a href="#union_types">union types</a> construction.
        <p>
            Motivation: we want to make a parametrized method, which type parameter is restricted to arbitrary set of types, ie: Int and Long.<br />
            We make using typeclass Acceptable - an abstract class, which perform as a type guardian for implicit objects, which perform evidence that the type can be used for desired method.</p>
					<pre><code class="scala">
                        abstract class Acceptable[T]
                        object Acceptable {
                        implicit object IntOk extends Acceptable[Int]
                        implicit object LongOk extends Acceptable[Long]
                        }

                        <i>// Our method:</i>
                        def f[T: Acceptable](t: T) = ...

                        import Acceptable._
                        <i>// now we can use f only with this argument type which are in Acceptable context.</i>
                    </code></pre>
    </div>

    <h4>Other interesting implementation using <em>type-classes</em></h4>
    <div>
        Interesting typeclasses:
        <ul>
            <li>Numeric</li>
        </ul>

        <br />
        Look <a href="http://www.scala-lang.org/api/current/scala/math/Integral.html">Scala.math.Integral</a> implementation. This class extends Numeric by two methods, and has interesting inner class which brings the feel of object methods instead of calling implicit object methods - eg:
			  <pre><code class="scala">
                  val x = some_val_with_Integral_support
                  val y = some_val_with_Integral_support
                  x % y                                     <i>// calls Integral[Int] .quot(x, y)   thanks internal implicit conversion to IntegralOps</i>
                  implicitly[ Integral[Int] ].quot(x, y)    <i>// normal call</i>
              </code></pre>
    </div>
</div>

<h3>Generic API</h3>
<div>
    The following example shows generic API design presenting the power that we get with typeclasses.<br />
    Here the <b>generic API implementation</b> means:
    <ul>
        <li><em>open</em> - allows multiple implementation. User can chose which one wants to use (by importing particular implicit object to current scope)</li>
        <li>works  with abstraction that user implement later.</li>
        <li>divide the code functionality to simple, small implicit object</li>
        <li>allows to dispatch (choose which implicit object needs to use) a function based on return type, function argument as well as current context</li>
        <li>all dispatch is static - at the end compiler insert right static code (not dynamic based on runtime)</li>
    </ul>
    This contrast what we could achieve with <em>subtyping</em>, where all subtypes are bound, in declaration time, by the contract that the super type exposes. This means subtyping are <em>closed</em> in contrast to <em>open</em> typeclasses.
    <br />

    <p>The example is about implementing Scala version of Read typeclass - which have one method: <code>read::(Read a) => String -></code> - function requires type <code>a</code> which implements class <code>Read</code>. The function takes string representation of type t, and returns instance of type a corresponding to that string.</p>

				<pre><code class="scala">
                    <i>// typeclass</i>
                    trait Read[T] {
                    def read(s: String): T
                    }

                    <i>// implementing instances for Read</i>
                    implicit object IntRead extends Read[Int] {
                    def read(s: String) = s.toInt
                    }


                    <i>// Our Object</i>
                    case class Name(firs: String, last: String)

                    object NameDescription {
                    def unapply(s: String) = {
                    val a = s.split("/")
                    Some(a(0), a(1))
                    }
                    }

                    implicit object NameRead extends Read[Name] {
                    import NameDescription._
                    def read(s: String) = s match {
                    case NameDescription(l, f) => Name(l, f)
                    case _  =>  sys.error("invalid")
                    }
                    }

                    <i>// we can also set up generic context for high level constructs:</i>
                    <i>// here we define implicit "object generator" in context Read</i>
                    <i>// compiler can make automatic make new instance of class Read for generic Seq[T] type,</i>
                    <i>//      - only if the type parameter T implement Read typeclass</i>
                    implicit def SeqRead[T : Read] = new Read[Seq[T]] {
                    def read(s: String) =
                    s.split(" ").toSeq map (implicitly[Read[T]] read _)
                    }

                    <i>// using</i>
                    def foo[T: Read](s: String) = implicitly[Read[T]] read s

                    foo[Int]("123")                <i>// returns 123 : Int</i>
                    foo[Name]("Robert/Zaremba")    <i>// returns Name("Robert", "Zaremba")</i>
                    foo[List[Int]]("1 2 3")        <i>// returns List(1,2,3)</i>
                </code></pre>

    Presented API becomes hugely expressive under the control of static type system. All this constraints are checked during compile time.
</div>
</div>

</div>



<h1>Polymorphism</h1>
<div>
    As wee see Scala has sophisticated type system with very clever type mixins, and type implicit conversions and type bounds.<br />
    Beside this Scala offers powerful type inference which allows to omit type declaration in common places.
    <p>
        All of this makes Scala to achieve polymorphism in multiple way - depends on the needs.<br />
        Moreover - all of them are orthogonal semantic concept, which Scala easy and powerful tool for <a href="http://debasishg.blogspot.com/2010/01/case-for-orthogonality-in-design.html">domain models</a>. - after Debasish words: <em>Great languages are those that offer orthogonality in design. Stated simply it means that the language core offers a minimal set of non-overlapping ways to compose abstractions.</em>
    </p>
    Polymorphism in Scala is make with:
    <dl>
        <dt>Inheritance with abstract class</dt>
        <dd>We make abstract base class and family of classes which inherit from this.<br />
            <a href="#inheritance">more</a>. The practical application for this is to construct family of classes which resolves to different construction (Animal &lt;- Fish, AnyRef &lt;- String )</dd>
        <dt>Inheritance with case classes</dt>
        <dd><a href="#case_classes">more</a>. Useful for flat class family, designed for pattern matching.
        </dd>
        <dt>Inheritance with Trait mixins</dt>
        <dd><a href="#traits">more</a> <a href="#pre-initialized_fields">more</a>. Trait serves to aggregate common functionality and to make some polymorphic functions which require this functionality.<br />
            So if function expect argument which is a Seq and has apply method we simply write the type as<br />
            <code>Seq with Function1</code><br />
            If every object from some class needs to have some library functionality we just mixin appropriate trait on the class	level. <br />
            Furthermore traits helps divide logic between:
            <ul>
                <li>base class - there should go only primary concept of a class (like changing variables, processing dependencies between related objects...)</li>
                <li>traits - they should contain features, presenting scenario, etc...</li>
            </ul>
            So every concern related to specific class should be make by a trait.
        </dd>
        <dt>Traits with abstract base class</dt>
        <dd>
            <a href="#traits">more</a>. They serves to build mixin functionality to specified class family. Traits with abstract base class use class members to build functionality and make dependency.
        </dd>
        <dt>Structural subtype</dt>
        <dd>
            <a href="#structural_types">more</a>. They serves to extends particular class (usually abstract one) on the fly (for example by specifying the type variable) - look the reverse method implementation in <a href="https://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/src/library/scala/math/Ordering.scala#L1">Ordering</a> trait.<br />
            Other use case would be to specify function argument type - for which we require to implement some set of Traits. Then we simply write the argument type as: <code>T1 with T2 ...</code>
            <p>Usually we use <b><a href="#abstract-type-field">type fields</a></b> when mixing traits or simply structural subtype.</p>
        </dd>
        <dt>implicit conversions - view bounds</dt>
        <dd>
            <a href="#view_bound">more</a>. Scala allows implicit convert one type to other (Eg: having class X, but design decision was to make it simple and small - so it don't mixin Ordered, but has implicit conversion to Ordered type).<br />
            View bound asserts existence an evidence for some conversion, functionality in current scope (by implicit functions). So the evidence function is used to make some object useful / properly in current operation.
            They are used to <u>enrich some type</u> (eg: StringOps, ArrayOps, RichInt ...)
        </dd>
        <dt>implicit objects - typeclasses</dt>
        <dd>
            <a href="#using_typeclass">more</a>. They are use to make some functionality more flexible (eg: to ensure that there is some order on specified type, but in different context the order on the same set of objects that type can be different)
        </dd>
    </dl>
</div>



<h1>Manifest and type parameters instantiating</h1>
<div>
    Due to type erasure we loose the type parameter in generics during class parametrization.<br />
    In some generic type <code>class C[T]</code> there is no way to directly instantiating type parameter in runtime using <code>new</code> because:
    <ul>
        <li>On the class level compiler doesn't have information about the type, and how a constructor looks like (how many and which type arguments take).</li>
        <li>in runtime the information about type parameter is erased due to <em>type erasure</em> -feature specified on JVM. So in runtime we don't know abut type parameter of a generic object.</li>
    </ul>
    To instantiate type parameter inside class we can use:
    <ul>
        <li>factory method passed to class constructor or some method which needs to construct instance of type parameter</li>
        <li>Using Manifest object</li>
    </ul>
    ... or directly put already constructed object as an argument to constructor / method.
    <h5>Using factory method</h5>
    <div>
        Factory method is a <em>design pattern</em> which take from us project constriction and instantiation. We simply call factory method, and the method itself recognize how to instantiate an object and which class to use (eg when using inheritance it sometimes might to create subclass object). More about <em>factory method design pattern</em> on <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Wikipedia pages</a>.<br />
        You should also consider <a href="#dependency-injection">dependency injection patter</a>.
			<pre><code class="scala">
                class BalanceActor[T &lt;: Actor](val fac: () => T) extends Actor {
                val workers: Int = 10

                private lazy val actors = new Array[T](workers)

                override def start() = {
                for (i &lt;- 0 until workers) {
                actors(i) = fac() //use the factory method to instantiate a T
                actors(i).start
                }
                super.start()
                }
                }

                <i>// using BalanceActor:</i>
                val ba = new BalanceActor[CalcActor]( { () => new CalcActor } )
                ba.start
            </code></pre>

    </div>
</div>



<h1>Parallel computation</h1>
<div>

    <h2>Snippets on parallel computation</h2>
    <div>
        <ul>
            <li>http://etorreborre.blogspot.com/2011/10/scala-collections-are-awesome.html</li>
        </ul>
    </div>

    TODO

</div>




<h1>Tips and popular structures</h1>
<div>
<h2>Interesting patterns</h2>
<div>
Really great presentation: <a href="http://skillsmatter.com/podcast/home/design-patterns-in-scala">PODCAST DESIGN PATTERNS IN SCALA</a>
<h3 id="dependency-injection">Dependency Injection</h3>
<div>
<em>Dependency Injection</em> is very popular pattern last time. Usually used to easily change some functionality depend of the environment it is used for.<br />
Dependencies are component which contains some functionality. We can create more version of some component and easily substitute them in other associated components.<br />
You can read more about DI: <a href="http://tutorials.jenkov.com/dependency-injection/index.html">http://tutorials.jenkov.com/dependency-injection/index.html</a> or on <a href="http://en.wikipedia.org/wiki/Dependency_injection">Wikipedia</a>.
<p>
    Scala is so flexible language, that you can achieve <em>Dependency Injection</em> in multiple way: using mixing, <em>Cake Pattern</em> and high-order Function.
</p>
<p>Functional Programming guru also claim, that in FP world there is no need for special DI framework, as high-order function are enough.
</p>
<p>Very good explanation of Scala flexibility is Martin Odersk'y paper: <a href="http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf">Scalable Component Abstractions</a>.
</p>
<h6>Dependency Injection and Factory pattern</h6>
<div>
    DI looks very similar to Factory pattern. But Software gurus actually aims to use DI. The key difference is that:
    <ul>
        <li>using a factory your code is still actually responsible for objects creation</li>
        <li>by DI you outsource that responsibility to a framework / other module which is separate from your code.</li>
    </ul>
    The drawback of Factory pattern are described at <a href="http://tutorials.jenkov.com/dependency-injection/dependency-injection-replacing-factory-patterns.html">http://tutorials.jenkov.com/dependency-injection/dependency-injection-replacing-factory-patterns.html</a>
</div>

<h4>Cake Pattern</h4>
<div>
    <em>Cake Pattern</em> is very clean way to make <em>Dependency Injection</em>, which use Scala flexibility.<br />
    <p>The key idea is that we compound every class/functionality in abstract component which has the instance of functionality as a field (val or parameter less method which gives us the instance). This field is used by other components which depends on it and we should delay coupling to any initialization of it till the time we absolutely need them. And that is when we make the assembly with this component.
    </p>
    <p>When some component (A) depends on other component (B) we use <a href="#self-type-annotations">self type annotations</a> (<code>self: B =></code>) to express this. So that if we want to use component A we need to mixin component B. At the end the the functionality in class A has an access to instance of functionality B, which is specified in creation time.<br />
        To get the full functionality assembling those components using mixins and construct an <em>object</em> or <em>instance</em> of it. It is similar to putting together different layers of a cake to form the final shape.
    </p>
    <p>If The Construction of the object depends on initialization order then the object of the functionality should be <em>lazy val</em>. Eg: Component A depends on component B and initialization of A requires some information from initialization of B.
    </p>

    <p>Since every trait can be mixed only once there is a limitation about using mixins. This is described <a href="#di-multiple-version-of-component">Constructor based DI</a> section.
    </p>

    General template:
              <pre><code class="scala">
                  // here we can make an trait to assure that every implementation of component would look that same:
                  trait Functionality1 {
                  val / lazy val / def functionality1 : Functionality1Impl
                  abstract class / trait Functionality1Impl { ... }
                  }

                  trait Functionality1Component_V1 extends Functionality1 {
                  self : Dependency1 with Dependency2 =>              // eg self: Functionality2 =>
                  class Functionality1Impl { .. }
                  }

                  trait Functionality1Component_V2  extends Functionality1 {
                  self : DependencyComponent1 with DependencyComponent2 =>
                  val _cached_functionality1 : Functionality1Impl     // still we delay with the instantiation
                  val / lazy val / def functionality1  = _cached_functionality1
                  class Functionality1Impl { .. }                     // other implementation
                  } </code></pre>

    <h6>def or var to express dependency instance?</h6>
    <div>
        If you use simply <em>val</em>, all implementations are locked and have to provide a single dependency instance (a constant). With a method, you can return different values on each invocation. For example, in a web environment, this is a great way to implement scoping! The method can read from the request or session state.<br />
        Still end components can have abstract vals, and define them when instantiating:
    </div>
    The whole example:
              <pre><code class="scala">
                  class User(val name: String) {
                  override def toString() = name
                  val username = name;
                  }

                  /****************************
                  * Functionality 1: retrieving users
                  * here functionality is not surrounded by the class
                  */
                  trait UserRepo{
                  val repo_address :String
                  println("> creating UserRepo instance to \""+repo_address+"\" repository")    // this will be printed each time...
                  //    ...when UserRepoMock is called from "def instance"
                  def find(name: String): Option[User]
                  }

                  //***   implementations of UserRepo   ***
                  class UserRepo1(val repo_address: String) extends UserRepo{
                  def find (name: String) =
                  if(name startsWith "r") Some(new User(name))
                  else None
                  }

                  class UserRepoMock(val repo_address: String) extends UserRepo{
                  def find (name: String) = {
                  println("mock find")
                  Some(new User(name))
                  }
                  }

                  //****   wrapping into component   ****
                  trait UserRepoComponent[T &lt;: UserRepo] {
                  def userRepo : T                        // here val or lazy val can be used as well
                  }

                  //***   examples about how to use User Repo Component   ***
                  object UserService extends UserRepoComponent[UserRepo1] {
                  def userRepo = new UserRepo1("main")   // because of def, there is creating new instance of UserRepo1
                  }                                        //    with every access to userRepo field

                  //***   or as the val   ***
                  object StartUserRepo {
                  val test_env = new UserRepoComponent[UserRepoMock] {
                  val _defaultUserRepo = new UserRepoMock("mock_repo")
                  def userRepo = _defaultUserRepo      // here we get the cached instance of UserRepo to avoid creating new instances on each call
                  }                                      //    because of using def we can still put some job (eg logging) to userRepo access
                  }


                  /****************************
                  * Functionality 2: User authorization
                  * usually we put the functionality inside an abstract component
                  * this puts the implementation in coherent namespace:
                  */
                  trait LoggerComponent {
                  val logger : Logger                     // here we are using val
                  trait Logger {
                  def log(ms: String)
                  }
                  }

                  trait LoggerComponentStd extends LoggerComponent {
                  val logger = new LoggerImpl            // val is specified on trait  definition so we can't simply ychanging in runtime,
                  //     only overriding on creation time.
                  class LoggerImpl extends Logger {
                  def log(ms:String) = println(ms)
                  }
                  }

                  trait LoggerComponentFile extends LoggerComponent{
                  //     we postpone the creation of val logger till creation of whole Application class time
                  class LoggerImpl extends Logger {
                  def log(ms: String) = println("logging to file: \""+ms+"\"")
                  }
                  class LoggerMockImpl extends Logger {                        // Mock class Version!
                  def log(ms: String) = println("logging to file mock: \""+ms+"\"")
                  }
                  }

                  /****************************
                  * Functionality 3: User Service which has Authorization and User Update
                  * this functionality depends on other components: UserRepoComponent and LoggerComponent
                  */
                  trait UserServiceComponent {
                  this : UserRepoComponent[_] with LoggerComponent =>   // here we <b>express dependencies</b>
                  def authorizator : Authorizator
                  val userUpdater = new UserUpdater                     // we set default instance here
                  trait Authorizator {
                  def authorize(usr: String, passwd: String) : Option[User]
                  def change_passwd(u: User, new_pass: String)
                  }
                  class UserUpdater {                                   // here is the default implementation for UserUpdater
                  def update(u:User) = println("User " + u.name + " updated" + u)
                  }
                  }

                  trait UserServiceComponentStd extends UserServiceComponent {
                  this : UserRepoComponent[_ &lt;: UserRepo] with LoggerComponent =>
                  val company: String       // traits can't has constructor nor parameters. So the abstract fields plays the role of trait parameter
                  val authorizator = new AuthorizatorStd(company)
                  class AuthorizatorStd(company: String) extends Authorizator {
                  def authorize(usr: String, passwd: String) = {
                  logger.log("trying to authorize "+usr + " from "+ company)
                  if(passwd == "ok") userRepo.find(usr)
                  else None
                  }
                  def change_passwd(u:User, new_pass: String) = println("Password changed")
                  }
                  }


                  /****************************
                  * Assemblingy everything together
                  */
                  object StartCake extends App {
                  val service = new UserServiceComponentStd with LoggerComponentFile with UserRepoComponent[UserRepo1] {
                  val company = "super company"                // needs to be lazy, since authorizator rely on this and it is aware of initialization order
                  // otherwise authorizator could bind company as a null value.
                  val logger = new LoggerImpl                  // logger instance was postponed
                  def userRepo = new UserRepo1("main")
                  override val userUpdater = new UserUpdater   // we can override the default value (actually for simplicity is the same).
                  }
                  println(service.userRepo.find("marta"))
                  service.userRepo.find("robert") match {
                  case Some(u) => println("found user robert")
                  case None    => println("user robert not found")
                  }
                  println(service.authorizator.authorize("robert", "ok"))
                  }
              </code></pre>


    Very good discussion about cake pattern: <a href="http://www.warski.org/blog/2011/04/di-in-scala-cake-pattern-pros-cons/">http://www.warski.org/blog/2011/04/di-in-scala-cake-pattern-pros-cons/</a>.
</div>

<h4>Constructor based DI</h4>
<div>
    <h6 id="di-multiple-version-of-component">Using Multiple version of some component using DI</h6>
    The following link contains clean solution about DI implemented by mixing of Cake Pattern and simply constructor / method parameters: <a href="http://stackoverflow.com/questions/5190328/can-the-cake-pattern-be-used-for-non-singleton-style-dependencies">http://stackoverflow.com/questions/5190328/can-the-cake-pattern-be-used-for-non-singleton-style-dependencies</a>

    <p>Full example showing constructor based DI<br /> which comes form: http://jboner.github.com/2008/10/06/real-world-scala-dependency-injection-di.html</p>
              <pre><code class="scala">
                  // UserRepo an UserRepo1 as previous

                  // other service
                  trait Logger {
                  def log(ms: String)
                  }

                  class LoggerStdOut extends Logger {
                  def log(ms:String) = println(ms)
                  }

                  // =======================
                  // service declaring two dependencies that it wants injected,
                  // is using structural typing to declare its dependencies
                  class UserService(val logger: Logger, val userRepo: UserRepo) {
                  def authorize(username :String) = {
                  logger.log("trying to authorize "+username)
                  userRepo.find(username)
                  }
                  }

                  class Client(us: UserService ) {
                  us.authorize("robert")
                  }

                  // =======================
                  // instantiate the services in a configuration module
                  object Config {
                  lazy val logger = new LoggerStdOut
                  lazy val userRepo = new UserRepo1("main")
                  lazy val userService = new UserService(logger, userRepo) // this is where injection happens
                  }

                  new Client(Config.userService)  // running the client code
              </code></pre>
</div>

<h4>Functional Programming based DI</h4>
<div>
    If we want to be functional, then all dependency should go through functions arguments. Specialization is done with currying.
              <pre><code class="scala">
                  // UserRepo and Logger as previous

                  trait UserService {
                  def authorize(ur: UserRepo, logger: Logger) : String => Option[Unit] = s => {
                  logger.log("trying to authorize: " + s)
                  ur.find(s)
                  }
                  def addUser(ur: UserRepo, logger: Logger) : String => Option[User] = s => {
                  logger.log("adding user: " + s)
                  if (ur find s) None
                  else Some(new User(s))
                  }
                  def sayHello(logger: Logger) : User => Unit = u => logger.log(u.name + " said hello")

                  // some test:
                  def test(ur:UserRepo) : String => Unit =
                  sayHello(addUser(ur, new LoggerMockImpl)( _ ), new LoggerMockImpl)

                  // we can do mystically using scalaz:
                  val test2 = for {
                  au_part &lt;- addUser(_, new LoggerMockImpl)      // make a partial function which will be extracted when applied
                  sh_part &lt;- sayHello                            // normal function which will be extracted when applied
                  } yield (au_part map sh_part)
                  }

                  // assembling through partial application
                  object UserService1 extends UserService {
                  val logger = new LoggerStdOut
                  val authorize1 = authorize1(new UserRepo1("main"), logger)
                  val addUser    = addUser(new UserRepo1("main"), logger)

                  test(new UserRepo1("main"))("test_user")
                  test2(new UserRepo1("main"))("test_user")
                  }

              </code></pre>
</div>
</div>
</div>


<h2>Reflections</h2>
<div>
    Nice text about getting class object from class instance is <a href="http://stackoverflow.com/questions/1135248/scala-equivalent-of-java-java-lang-classt-object">here</a>
</div>

<h2>Generic reified</h2>
<div>
    <h3>Scala: Abstract Types vs Generics</h3>
    <div>
        read: <a href="http://stackoverflow.com/questions/1154571/scala-abstract-types-vs-generics">http://stackoverflow.com/questions/1154571/scala-abstract-types-vs-generics</a>
    </div>
    <h3>Generic reified</h3>
    <div>
        Scala, or JVM has a problem with extending a class by some trait multiple times, but with different parametrization, eg:
			<pre><code class="scala">
                trait Y[T]
                class X extends Y[A] with Y[B]
            </code></pre>
        Scala 2.10 is going to have some partial solution.<br />
        More on this: <a href="http://stackoverflow.com/questions/8605329/reified-generics-in-scala-2-10">http://stackoverflow.com/questions/8605329/reified-generics-in-scala-2-10</a>

    </div>
</div>

<h2>Creating jars</h2>
<div>
    <a href="http://stackoverflow.com/questions/809138/creating-a-jar-file-from-a-scala-file">creating a jar from a scala file</a>
</div>
<h2>Omitting dot and parentheses</h2>
<div>
		<pre><code class="scala">
            "a b c".split(" ").toSeq map ("L"+)  <i>// split returns Array[String] which doesn't have toSeq method, but WrappedArray has.</i>
            <i>// This requires implicit conversion from Array to ArrayWrapper toSeq</i>
            <i>// but the problem is with `map` function</i>
            ("a b c".split(" ").toSeq map ("L"+)  <i>// Other way to write this expression</i>
        </code></pre>

    <h3 class="none"></h3>
    <h4>Omitting brackets for generics</h4>
    <div>
        We can omit bracket when specifying generic type:
			<pre><code class="scala">
                trait Handles[-A, -E &lt;: Event]
                class Inventory
                class CreationEvent extends event

                def f(arg: Inventory Handles CreationEvent)    <i>// the same as Handles[Inventory, CreationEvent]</i>
            </code></pre>
    </div>

</div>
</div>



<h2>Tips for common methods</h2>
<div>
    <ul>
        <li><code>List.:+</code> = List.append. Not effective. Normal list is immutable stack.</li>
        <li><code>sys.error</code> - Throw a new RuntimeException with the supplied message. Its proffered to Predef.error (which is deprecated).</li>
        <li>running external processes <a href="http://stackoverflow.com/questions/6013415/how-does-the-scala-sys-process-from-scala-2-9-work">here</a></li>
    </ul>

</div>

<h2>Circular type dependency</h2>
<div>
    Suppose that in one module we want to create two types which depend on themselves:
    <ul>
        <li><code>Container[T]</code> - contains objects of type T. We want to T&lt;:Element</li>
        <li><code>Element[T]</code> - we want to store in each element the enclosing container, so T is the type of container which has the element.</li>
    </ul>
    So the motivation is to ensure at compile time using type system the symmetric dependency.

		<pre><code class="scala">
            abstract class Container[E &lt;: Element[_]] {
            def contains( e: E ): Boolean
            def addNewElement(): Unit
            }

            abstract class Element[C &lt;: Container[_]] {
            def enclosingContainer(): C
            }

            class MyContainer extends Container[MyElement] {
            private var elements = List[MyElement]()
            override def contains( elem: MyElement ) = elements.contains( elem )
            override def addNewElement() { elements ::= new MyElement(this) }
            }

            class MyElement( container: MyContainer ) extends Element[MyContainer] {
            override val enclosingContainer = container
            }
        </code></pre>
</div>


<h2><a href="http://en.wikipedia.org/wiki/Type_polymorphism#Rank-n_.28.22higher-rank.22.29_polymorphism">Rank-k polymorphism</a></h2>
<div>
    We have some generic function f: <code>f[T]: T=>T</code> and we want to make function <code>z</code> which takes f as an argument and operate on two parametrized version of f, eg calls f[Int] and f[Double].<br />
    The problem is that we need to declare the type of f in z definition.<br />
    We simply can't make it like this:
		<pre><code class="scala">
            z[T](f: T => T) = f[Int](1) + f[Double](2.2)     <i>// error!</i>
        </code></pre>
    this not works, because we use here f as it has two types (Int => Int, and Double => Double).<br />
    The solution is to use class/trait wrapping the generic function:
		<pre><code class="scala">
            trait ForAll {
            def wrapper[X](x : X) : X
            }
            def z(wop : ForAll) = wop.wrapper[Int], wop.wrapper[Double])

            <i>// using:</i>
            def f[T](x: T) = x
            z(new ForAll{def wrapper[X](x : X) = f(x)})
        </code></pre>
</div>


<h2 id="union_types" >Union types</h2>
<div>
    Similar construction, not based on types operation you can find in <a href="#narrowing_types">narrowing types</a> section.
    Motivation: we want to make construction to express the type to be either <code>T1</code> or <code>T2</code> and we call it <em>Union Type</em>.

    <p>This can be also useful for method overloading using generic types. </p>
    <h3>Using generic class with two fields</h3>
    <div>
			<pre><code class="scala">
                case class OrType[A,B](val a: Option[A], val b: Option[B])

                object OrType {
                type or[A,B] = DisjointType[A,B]                             <i>// to type "or" instead of "OrType"</i>

                private def da[A,B](a: A): or[A,B] = { DisjointType(Some(a),None) }
                private def db[A,B](b: B): or[A,B] = { DisjointType(None,Some(b)) }

                // implicit defs - stuttering-or
                implicit def aToOrType2[A,B](a: A): or[A,B] =
                { da(a) }
                implicit def bToOrType2[A,B](b: B): or[A,B] =
                { db(b) }
                implicit def aToOrType3[A,B,C](a: A): or[or[A,B],C] =
                { da(da(a)) }
                implicit def bToOrType3[A,B,C](b: B): or[or[A,B],C] =
                { da(db(b)) }
                }

                <i>// using:</i>
                import OrType._
                class Foo {
                def erasureMethod[T &lt;% String or Int](lt: List[T]) = {
                for (x &lt;- lt) x match {
                case x: String => println("String list item: " + x)
                case x: Int => println("Int list item: " + x)
                }
                }
                }
            </code></pre>
        <p>The drawback of this solution is that we have a new class type with two "subtypes" (two fields).<br />
            Below is better solution using sophisticated type system constructions.</p>
    </div>

    <h3>Using logic construction</h3>
    <div>
        We construct <em>Union Type</em> using Curry-Howard isomorphism - to transform types to logic. The built in construct logic operators on a types is <em>inheritance</em> - using with or extends keywords.
			<pre><code class="scala">
                type ¬[A] = A => Nothing
                type v[T, U] = ¬[¬[T] with ¬[U]]                       <i>// DeMorgan law</i>
                type ¬¬[A] = ¬[¬[A]]
                type |v|[T, U] = { type λ[X] = ¬¬[X] &lt;:&lt; (T v U) }

                <i>// Using</i>
                def size[T: (Int |v| String)#λ](t: T) = t match {
                case i: Int => i
                case s: String => s.length
                }

                size(3)                        <i>// returns 3: Int</i>
                size("hej there")              <i>// returns 9: Int</i>
                size(4.2)                      <i>// error: Cannot prove that ((Double) => Nothing) => Nothing >: Nothing with (java.lang.String) => Nothing) => Nothing.</i>
            </code></pre>
        Why is the additional <code>|V|</code>? Because <code>implicitly[Int &lt;:&lt; (Int ∨ String)]</code> (asking the compiler if it can prove that Int is a subtype of Int ∨ String) simply not gets true. The left hand of <code>&lt;:&lt;</code> is Int, and the right is a function (because ¬ is a function type). We need to transform right hand of <code>&lt;:&lt;</code> to some other type. That's why we have ¬¬ and |v| types.
        <p>More elaboration about union type construction on <a href="http://www.chuusai.com/2011/06/09/scala-union-types-curry-howard/">Miles Sabin blog</a>
        </p>

        <h4>How far we can go types expressions</h4>
        <div>
            In the propositional calculus it is possible to express all terms using negation and disjunction.<br />
            So in Scala it also becomes possible using the definition from above.

            <p>Since <a href="http://michid.wordpress.com/2010/01/29/scala-type-level-encoding-of-the-ski-calculus/">type level calculations in Scala are Turing complete</a> it should be possible to find type construction corresponding to any recursive function. This means that – in theory at least – Scala's type system is powerful enough to express any type whose set of values is recursive.
            </p>
            <p>
                To find the construction for any recursive function we can generalize our <code>|v|</code> type constructor to the concept of <em>Acceptor</em>:</p>
				<pre><code class="scala">
                    type Acceptor[T, U] = { type λ[X] = ... }
                </code></pre>
            and for any function try to construct corresponding type level <em>Acceptor</em>
        </div>
    </div>
</div>


<h2>Unboxed Tagged Types</h2>
<div>
    Motivation: we have some basic structure, that can represents several concepts, eg: Int can be a number seconds from EPOCH as well as the number of seconds from the day beginning.<br />
    To avoid mistakes with the Int interpretation we need to occupy type system to control our value interpretation.
    <p>We can set some interpretation for value by boxing it into higher type or <em>refine a type</em></p>

    <h3 class="none"></h3>
    <h4>Using boxing</h4>
    <p>The classic approach is to box Int into two classes which represent day seconds, and epoch seconds. This leads to new type in a class hierarchy and extra memory space.</p>

    <h4>Tagged types</h4>
    <div>
        This approach use type system without creating extra classes.
        <p>
            Quiet good code snippets about unboxing type: <a href="https://gist.github.com/89c9b47a91017973a35f">https://gist.github.com/89c9b47a91017973a35f</a>.
        </p>
        Unboxed Tagged Types are <b>part of the scalaz7</b>
			<pre><code class="scala">
                type Tagged[U] = { type Tag = U }     <i>// type refinement using type alias</i>
                type @@[T, U] = T with Tagged[U]      <i>// type constructor</i>

                trait Day
                trait Epoch

                type Epochtime = Long @@ Epoch        <i>// type aliases for Long type with tag refinement</i>
                type Daytime   = Long @@ Day

                <i>// conversion functions:</i>
                def daytime(i: Long): Daytime     = i.asInstanceOf[Daytime]
                def epochtime(i: Long): Epochtime = i.asInstanceOf[Epochtime]

                <i>// we can use <a href="#pimp_my_library">pimp my library pattern</a> to add extra functionality:</i>
                val hhmmFormat = new SimpleDateFormat("hh:mm")
                case class EpochtimeDisplay(time: Epochtime) {
                <i>// here new Date expects a Long, but this is ok because Epochtime *is* a Long</i>
                def hhmm = hhmmFormat.format(new Date(time))
                }
                implicit def toEpochtimeDisplay(t: Epochtime) = new EpochtimeDisplay(t)

                <i>// using:</i>
                def calculateDay(e: Epochtime) = ...
                val e = epochtime(10231231)
                val d = daytime(2231)
                e.hhmm
                calculateDay(e)                <i>// OK</i>
                calculateDay(d)                <i>// Error</i>
            </code></pre>
    </div>
</div>


<h2>Popular data structures</h2>
<div>
    <h3 class="none"></h3>

    <h4>Arrays</h4>
    <div>
        <code>new Array[Int](size), Array("mama", "tata")</code>, the last one is an apply method from companion object
        <p>indexing is made through <em>apply</em> method call, eg: <code>tab(i)</code></p>
    </div>

    <h4>Lists</h4>
    <div>
        Scala has several implementation of Lists:
        <ul>
            <li><code>scala.collecion.immutable.List (default)</code> - functional type. Most operations are recursive. Operations which can't be tail recursive (map) are implemented imperatively using ListBuffer, and at the end converting to the List (which is efficient - see below).<br />
                Instances are created by type constructor (List(elems), or ::, Nil),
            </li>
            <li><code>ListBuffer</code> - "normal", mutable list. Are created by <code>new</code>.<br />
                Can invoke <code>toList</code> to convert itself to immutable list. This operation is efficent and independent of the List size. <br />
                <b>Caution</b>: once <code>toList</code> is called on ListBuffer, then every mutable operation on a list (eg append) requires copy of the whole list! reed more in <em>Programming in Scala, 22.3</em></li>
            <li><code>scala.collecion.mutable.MutableList </code></li>
        </ul>
        List are covariant, and empty list is type List[Nothing] and  Nothing is the bottom type in Scala’s class hierarchy, so for any type <code>A, List[Nothing]</code> is subtype of <code>List[A]</code>.
    </div>

    <h4>Tuples</h4>
    <div>
        <code>var x=(1, "22", 'a')</code>. Access: <code>x._1</code>. It is impossible to make  apply method which gets particular field - because such method needs to return different data types (depends on which field returns).
    </div>

    <h4>zipped</h4>
    <div>
        Tuple.zipped is a function which takes a tuple, and return Zipped instance which has implemented variants of methods  <em>map, flatMap, foreach</em> which operates on both elements of tuple (instead of one on single list).
    </div>

    <h4>Map, Set</h4>
    <div>
        <p>
            <code>scala.collections.(mutable | immutable).Map</code>, eg: var x = Map(1->"one", 2->"two")
        </p>
        <p>
            <code>scala.collections.(mutable | immutable).Set</code>, eg: var x = Map(1->"one", 2->"two")
        </p>
        The default types imported with Predef are the immutable types. <br />
        For objects of <code>immutable</code> type <em>var</em> doesn't have sense (var x = scala.collections.immutable.Set)
        <ul>
            <li>+  returns new Map with extra element, eg: <code>var y = x+(3->"three")</code></li>
            <li>+=  adds new element, CAUTION: only with <em>var</em> variables of mutable type eg: <code>x += (3->"three")</code></li>
        </ul>
    </div>


    <h2>Tips for web development</h2>
    <div>
        <h3 class="none"></h3>
        <div>
            <h4>Web servers</h4>
            <div>
                <ul>
                    <li><a href="http://stackoverflow.com/questions/5122345/why-use-apache-web-server-in-front-of-glassfish-or-tomcat">Point to use Web server in front of application server</a></li>
                </ul>
            </div>
        </div>
    </div>
</div>




<br /><br />

<h1>Nice libraries</h1>
<div>
    <h2 class="none"></h2>
    <h3>Scalaz</h3>
    <div>
        Scalaz brings to Scala some generic functions and abstractions that are not there in the current Scala API.<br />
        Typeclasses are the cornerstone of Scalaz distribution. Instead of thinking polymorphically in inheritance hierarchies, think in terms of designing APIs for the open world using typeclasses. Scalaz implements the Haskell hierarchy of typeclasses - Functors, Pointed, Applicative, Monad and the associated operations that come with them.

        <h4>Introduction to basic algebra structures</h4>
        <div>
            An algebra structure is A=(G, O) set of common objects <code>O</code>, and a operators <code>G</code> (functions) on this objects. Operators are closed under <code>G</code> (every call of the operator gives an element from <code>G</code>)

            <h5>Semigroup</h5>
            Is an algebra which has associative binary operation.

            <h5>Monoid</h5>
            Is an <em>semigroup</em> which have a neutral element <code>e</code> in G, for given semigroup binary operator.

            <h5>Group</h5>
            Is an <em>Monoid</em> which have an inverse <code>Inv</code> operator for every element in G, such that <code>Inv(g)+g=e</code>, where  e is neutral element and + is binary operator given from semigroup.

            <h5>Functor</h5>
            Is an algebra supporting "simple kind homomorphism" operations.<br />
            In Functional programming it means, high order structures (containers) that supports <code>map</code> operator, which maps function to every element in the structure.

            <h5>Monads</h5>
            high order structures which are Functor and has "flatMap" like method

        </div>


        <h4>The principals behind Scalaz</h4>
        <div>
            Scalaz introduces 3 main kind types (the interpretation of "normal" types): Identity[_], MA[_,_], MAB[_,_,_]:
            <ul>
                <li><code>A ~> Identity[A]</code> which means that any non-generic type a is a kind of Identity[_] - there exists implicit conversion from A to Identity[A]  (like Int, String, ...)</li>
                <li><code>M[A] ~> MA[M,A]</code> - any generic type with one type parameter is a kind of MA[_,_] - there exists implicit conversion from M[A] to MA[M, A] (like Set, List, Option...)</li>
                <li><code>M[A, B] ~> MAB[M,A, B]</code> - any generic type with two type parameters is a kind of MAB[_,_,_] - there exists implicit conversion from M[A,B] to MAB[M, A, B]</li>
            </ul>

            <h5>Monoid</h5>

            <code>Identity, MA, MAB</code> kinds are accepted to be Monoid.<br />
            The examples below show some monoids (type, operation, neutral element on the operation):
            <ul>
                <li>(Int, +, 0); (Int, *, 1)</li>
                <li>(Boolean, + == `or`, false); (Boolean, `and`, true) - scalaz introduce BooleanConjunctino for the last type, for which + is default to `and`</li>
                <li>(Boolean, + == `or`, false); (Boolean, `and`, true) - scalaz introduce BooleanConjunctino for the last type, for which + is default to `and`</li>
                <li>(Function2, + == `andThen`, id);</li>
                <li>(Option, + == `or`, None);</li>
            </ul>

            Scalaz kinds are monoids if:
            <ul>
                <li>Identity[A] if A is Monoid</li>
                <li>MA[M, A] if A is Monoid</li>
                <li>MAB[A, B] if B is Monoid</li>
            </ul>
            So for example Function2[A,B] is monoid if return type (B) is monoid.<br />
            I will present some useful operators on monoids, which are defined by scalaz:
            <dl>
                <dt>|+|</dt>
                <dd>Scalaz defines <code>|+|</code> for default operation on monoid (eg: for Boolean `or`)
                    <p>
                        With monoid we can perform very useful operations.
                        For example:
                    </p>
					<pre><code class="scala">
                        trait TradingPosition{
                        def sym: Ticker
                        def qty: Int
                        }

                        val f_london = (_ : TradingPosition).sym.id endswith ".L"
                        val f_ny = (_ : TradingPosition).sym.id endswith ".O"

                        val positins: Seq[TradingPosition] = get_positions_from_db("mydb")
                        positions filter (f_london |+| f_ny)                  <i>// returns positions from london or ny</i>
                    </code></pre>
                </dd>

                <dt>~</dt>
                <dd>~ is a "zero operation"
				  <pre><code class="scala">
                      val pos_map: Map[Trade, Int]  = get_positins...      <i>// other view to look at the position: map from ticker to quantity</i>

                      <i>// With new tread we want to increase the quantity in pos_map</i>
                      def newTrade(trd : Trade): Unit =
                      pos_map += (trd.sym -> (pos_map.get(trd.sym) getOrElse 0) + trd.qty)
                      <i>// the previous statement can be simplified to:</i>
                      pos_map += (trd.sym -> ~pos_map.get(trd.sym) |+| trd.qty)  <i>// this has other advantage, that Int type doesn't appear hear</i>
                      <i>// so we can safely change representation from Int to pair of Int's</i>
                  </code></pre>
                </dd>
            </dl>

            <h5>Function wrappers</h5>
            Scalaz defines function wrappers for <code>Function0, Function1, Function2</code> structures: <code>Function0W,Function1W, Function2W</code>
            Function1W, and Function2W define some interesting methods:
            <dl>
                <dt>Function1W, Function2W .lift</dt>
                <dd>Lift the function to higher kind Monad like, so that we can apply the function A=>B on collection (Functor) of A:<br />
                    <code>f.lift[<i>Container_type</i>] apply container</code> means <code>container map f</code>
					<pre><code class="scala">
                        val g = (_:Int)+1
                        g.lift[List] apply List(2,3) assert_=== List(3,4)
                        g.lift[List].second apply (1, List(2,3)) assert_=== (1, List(3,4))  <i>// see second definition in Array type below</i>

                        val f = (a:Int) => (a, List(a+1,a+2))
                        f andThen g.lift[List].second apply 1 assert_=== (1, List(3,4)
                        <i>// here we compose f and g to second element of f result</i>
                        f(1):-> g.lift[List] assert_=== (1, List(3,4))     <i>// the same effect as above, see :-> definition below</i>
                    </code></pre>
                </dd>
            </dl>

            <h5>Arrow</h5>
            Arrow is an wrapper to an function. Arrow expose two important functions: <code>first, second</code> which expects a pair as an argument and apply the function to first, or second element of the pair. There exists implicit conversion from Function1 to Arrow.
            <dl>
                <dt>Arrow.first</dt>
                <dd><pre><code class="scala">((_:Int) + 1).first apply (7, "abc") assert_=== (8, "abc")</code></pre></dd>

                <dt>Arrow.second</dt>
                <dd><pre><code class="scala">((_:String) + 1).second apply (7, "abc") assert_=== (7, "abc1")</code></pre></dd>

            </dl>



            <h5>MAB kind</h5>
            MAB representative is a Function1[_,_] type, Pair, Either
            <dl>
                <dt>MAB.&gt;&gt;&gt;</dt>
                <dd><code>((_: Int)+ 2) >>> (_*3) apply 2 assert_=== 12</code></dd>

                <dt>MAB.&lt;&lt;&lt;</dt>
                <dd><code>((_: Int)+ 2) MAB.&lt;&lt;&lt; ((_:Int)*3) apply 2 assert_=== 8</code></dd>

                <dt>MAB.&amp;&amp;&amp;</dt>
                <dd><code>((_: Int)+ 2) &amp;&amp;&amp; (_*3) apply 2 == (4,6)</code></dd>

                <dt>MAB.***</dt>
                <dd><code>((_: List[Int]):+ 3) *** ((_:Int) + 10) apply (List(1,2), 7) == (List(1,2,3), 17)</code></dd>

                <dt>MAB.product</dt>
                <dd><code>((_:Int) + 1).product apply (9, 99) assert_=== (10, 100)</code></dd>

                <dt>MAB.:-&gt;</dt>
                <dd>This operate only on BiFunctor type (Functor ~ Container of only two elements, like Pair, Either..)<br />
                    <code>(1,2) :-> (_ * 2)  assert_=== (1, 4)</code><br />
                    <code>((_:Int) * 2) &lt;-: (1,2) assert_=== (2, 2)</code><br />
                    <code>(Left(2): Either[Int, Int]):->(_*2) assert_=== Left(2)</code><br />
                    <code>((_:Int)*2) &lt;-: (Left(2): Either[Int, Int]) assert_=== Left(4)</code><br />
                    <code>(Right(2): Either[Int, Int]):->(_*2) assert_=== Right(4)</code><br /></dd>
            </dl>

        </div>

        <h4>Strings in Scalaz</h4>
        <div>
            Scala usually operates on <code>List[Char]</code> instead of <code>String</code>.
            To make use of String in Scalaz instead of converting <code>List[Char]</code> to <code>String</code>, we need to explicitly put some implicit objects to method call.<br />
            Some explanation is at <a href="http://stackoverflow.com/questions/7631844/string-seen-as-a-monoid">http://stackoverflow.com/questions/7631844/string-seen-as-a-monoid</a>
        </div>

        <hr />
        <p>nice articles, tutorials about scalaz:</p>
        <ul>
            <li><a href="http://stackoverflow.com/tags/scala/info">Scala "wiki" - info pages on SO</a></li>
            <li><a href="http://debasishg.blogspot.com/2010_11_01_archive.html">Some intro about Scalaz</a></li>
            <li><a href="https://github.com/jrwest/learn_you_a_scalaz">learn you a scalaz</a></li>
            <li><a href="http://dnene.bitbucket.org/docs/scalaz-guide/index.html">scalaz guide</a></li>
            <li><a href="http://stackoverflow.com/questions/4863671/good-scalaz-introduction">scalaz introduction sties</a></li>
            <li><a href="http://skillsmatter.com/podcast/home/practical-scalaz-2518/js-2679">http://skillsmatter.com/podcast/home/practical-scalaz-2518/js-2679</a></li>
            <li><a href="http://www.infoq.com/presentations/Scalaz-Functional-Programming-in-Scala">Scalaz - functional programming in Scala</a></li>
        </ul>
    </div>

    <h3><a href="https://github.com/okomok/sing">Sing</a></h3>
    <div>
        <em>sing</em> is a type-level metaprogramming library for Scala. This is based upon the singleton type system emulation. "sing" represents "singleton" and "compile-time and runtime methods sing in chorus":
    </div>
</div>



<h1>Processing xml with Scala</h1>
Good introduction is <a href="http://sites.google.com/site/burakemir/scalaxbook.docbk.html?attredirects=0">hera</a>.<br />
Mark Feeney covers quick intro about reading xml files in his <a href="http://blog.markfeeney.com/2011/03/scala-xml-gotchas.html">article</a>.<br />
Overwiev of the library on the <a href="http://www.codecommit.com/blog/scala/working-with-scalas-xml-support">code commit</a>


<h1>Nice Scala content</h1>
<div>
    <h2>Tools</h2>
    <div>
        My number 1 development configuration is <b>Emacs</b> + <b>Ensime</b> + <b>scamacs</b> (package with preconfigured build of emacs ecb) + <b>JRebel</b>. The build tool is <b>SBT</b> which is handled by Ensime. But usually I use SBT in separate xterm session - other window, more clean visibility in project.
        <p>But for those preferring simply without special emacs/vim abilities I would recommend IntellJ + SBT + sbt-idea (plugin for sbt) + sbt plugin for intellJ. I prefer IntellJ configuration then Eclipse, because of nice configuration of environment. It don't depends on internal Scala environment so I can use my general Scala environment, or what is better - easily manage sbt as a build tool. Then all dependencies and build process will be managed by SBT while coding and interface development will be managed by IntellJ.<br />
            If you want to use IntellJ you can track <a href="http://blog.jetbrains.com/scala/">intelliJ Scala plugin blog</a> which publish nice update information.
            When I tried to configure Eclipse it was like war with the hell - I couldn’t figure how can I change my Scala version or easy make run / build configuration (eg: to use sbt for building, and specify run configuration for output of sbt).
        </p>
        <h3 class="none"></h3>
        <h4>FSC</h4>
        <div>
            Scala compilation process usually takes a long time. The reasons are: JVM startup, Scala compiler warmup and time to load and JIT Scala libraries.
            <p>
                To speed up compilation process we can use <em>fsc</em> which is bundled with standard Scala. On the first time it runs standard Scala, make whole warmup and loading and stay detached as a daemon process in background. So in following fsc call, it will reuses the same compiler instance without spending whole time to load and JIT.
            </p>
            <p>fsc is usually supported by new IDEs (IntelliJ) - more info on <a href="reuses the same compiler instance">reuses the same compiler instance</a></p>
        </div>
        <h4>SBT</h4>
        <div>
            Simple Build Tool - must have and must learn for Scala developer.<br />
            Simple for building, simple for manage versions/dependencies, simple for running (servers, complicated environment configurations). Lots of plugins. Easy to write ones...
            To start using SBT check <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Setup">getting started page</a>.
            <p>SBT only recompile sources that are out of date. <br />
                Unfortunate (as of version 0.11) sbt doesn't use fsc to speed up compilation, but it uses the same JVM on each compilation process. So it avoids JVM startup overhead, but still needs a time for Scala compiler warmup and JIT libraries.
            </p>
            <p>As of 10.x and 11.x version SBT doesn't have built in task to setup new project. To start SBT just go to your project catalogue and run SBT and type task to preform.
                <br />The most basic tasks are</p>
            <ul>
                <li><code>compile</code> to look for the source files and compile them. sbt will compile only those with new changes.</li>
                <li><code>run</code> looks for class with <em>main</em> function and run it</li>
            </ul>
            As stated in getting started pages, SBT by default checks <code>./;  src/main/scala; src/main/java</code> subdirectories to find source files (eg: for compile task) and uses <code>target/&lt;scala-version&gt;/...</code> for .class files.
            All of this, and more (setting project version, scala-compiler version, compiler options, dependencies, classpath, owner/organization, copyright, packaging options ...) can be specified in build.sbt and project/&lt;.scal or .sbt&gt;  files. Further specification is on Wikipedia.
            <p>SBT perform dependency management as well as automated downloading of missing.</p>
            <p>SBT performs excellent as a build tool and running scala applications and scripts! With SBT you don't need any Scala build - just SBT. It will download and manage anything else you need</p>

            <h5>SBT plugins</h5>
            They are use to add new tasks and functionality for sbt. I will mention only couple of interesting plugin:
            <dl>
                <dt>np (<a href="https://github.com/softprops/np">New Project</a>)</dt>
                <dd>SBT lack a wizard task to make new project. Here np plugin comes. Simple utility for creating new projects in sbt. When active, in new folder run:
          <pre><code class="no-highlight">
              $ sbt
              $ np name:my-sub-project dir:sub-project-dir     </code></pre>
                    This will create a new sbt project source tree for a project named my-sub-project under the directory named sub-project-dir relative you your projects base directory.
                </dd>

                <dt>coffeescripted-sbt</dt>
                <dd><a href="http://coffeescript.org/">CoffeScript</a> is an programming language which is translate to JavaScript. It is very pleasant to use.<br />
                    The plugin compiles your CoffeeScripts so you don't have to.
                </dd>

                <dt><a href="https://github.com/aemoncannon/ensime-sbt-cmd">ensime-sbt</a></dt>
                <dd>Adds command <code>ensime generate</code> to sbt which generates .ensime project file. Similar functionality from ensime is really restricted and don't parse sbt builds file (just detects them).</dd>

                <dt><a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a></dt>
                <dd>This adds task to make an idea project from existing sbt project and configure it to use libraries from sbt cache<br />
                    Type <code>gen-idea [with-classifiers | no-classfiers | no-sbt-classifiers]</code> sbt task to create IDEA project files. By default, classifiers (i.e. sources and javadocs) of sbt and library dependencies are loaded if found and references added to IDEA project files. If you don't want to download/reference them, use command gen-idea no-classifiers no-sbt-classifiers.
                </dd>

                <dt><a href="https://github.com/n8han/posterous-sbt">posterous-sbt</a></dt>
                <dd>automatic publishing release notes to any Posterous site based on  current version and notes in notes/&lt;version&gt;.markdown  information.
                </dd>
            </dl>


            <h5>SBT tools</h5>
            SBT can be configured to perform as a "different application".<br />
            Instruction how to configure the behaviour of SBT read <a href="https://github.com/harrah/xsbt/wiki/Launcher">SBT Launcher wiki</a>.
            <p>Some interesting tools build on top of SBT.
            </p>
            <dl>
                <dt><a href="https://github.com/n8han/giter8">giter8</a></dt>
                <dd>is an command line tool which check for a skeleton of some project configuration you might want to use.  It simply search repository for template to use and download it to your localhost.
                    <p>After running <code>g8</code> it will output usage. It is as simple as <code>g8 -l</code> to list templates and <code>g8 repo_name/template_name</code> to download template.
                    </p>
                </dd>

                <dt><a href="https://github.com/softprops/ls#readme">ls</a></dt>
                <dd>A card catalogue for Scala libraries. Used as a tool based on sbt or web application at <a href="http://ls.implicit.ly/">http://ls.implicit.ly/</a>.<br />
                    Encourage to share information about self projects to ls.implicit.ly site (information on the site, on publishing section)
                </dd>
            </dl>

        </div>


        <h4>Ensime</h4>
        <div>
            Ensime is the ENhanced Scala Interaction Mode for Emacs. Really great extension to Emacs lovers.<br />
            It has support for sbt!
            <p>The simplifies .ensime configuration file to work with single Scala file (no directory structure).</p>
        <pre><code class="no-highlight">
            ( :source-roots (".") )
        </code></pre>
            There is also <a href="https://github.com/jonshea/minimal-ensime-sbt-project">minimal ensime sbt project</a>.
            <p>Below I present some tips in configuration ensime</p>

            <h6>Enable semantic highlighting</h6>
            <p>By default Emacs uses syntactic highlighting in sources. Because a syntax highlighter cannot tell whether a symbol is val or var, or a method call it is recommended to enable the semantic highlighter by the snippet below to your .emacs file.</p>
        <pre><code class="lisp">
            (setq ensime-sem-high-faces
            '(
            (var . (:foreground "#ff2222"))
            (val . (:foreground "#111111"))
            (varField . (:foreground "#ff6666"))
            (valField . (:foreground "#666666"))
            (class . font-lock-type-face)
            (trait . (:foreground "#084EA8"))
            (object . (:foreground "#026DF7"))
            (package . font-lock-preprocessor-face)))
            (param . (:foreground "#111111"))
            (functionCall . (:foreground "#84BEE3"))
        </code></pre>
        </div>

        <h6>Extending source roots</h6>
        <p>To link external sources (eg to extend type inferencer or symbol autocompleter) we need to extend <code>:source-roots</code> variable. We can do it in .ensime file or load manually in external script.
        </p>
      <pre><code class="lisp">
          key(":source-roots"), sexp(
          "/opt/scala/proj/play/src/scala",
          "/opt/scala/proj/scalaz/src/scala",
          )
      </code></pre>

        <h6>Linking to external documentation</h6>
        <p>We load external documentation by writing extractor function (which extracts appropriate files) and append it to <code>ensime-doc-lookup-map</code> list</p>
      <pre><code class="lisp">
          (defun make-play-doc-url (type &amp;optional member)
          (ensime-make-java-doc-url-helper
          "file:///opt/scala/proj/play2/doc/api/scala/" type member))

          (add-to-list 'ensime-doc-lookup-map '("^play\\.api\\." . make-play-doc-url))
      </code></pre>

        <h4>JRebel</h4>
        <div>
            JRebel is a JVM-plugin that makes it possible for Java developers to instantly see any code change made to an app without redeploying. JRebel lets you see code changes instantly, versioning classes and resources individually and updating one at a time instead of as a lump application redeploy. When developers make a change to any class or resource in their IDE, the change is immediately reflected in the deployed application, skipping the build and redeploy phases and preventing an average of 5.25 work weeks per year in redeploys. In June 2011, JRebel was recognized as "Most Innovative Java Technology" by the JAX Innovation Awards.
            <p>JRebel is an alternative solution to updating classes introduced in JVM 1.4 as a hot swapping feature that allows developers to update the code, limited to exists method bodies only, on-the-fly during debugging. JRebel does not require a debugging session to be started. Instead it monitors the file system for changes and updates the classes in-memory. This means that only classes compiled to ".class" files will be updated and changes to classes in JAR files will be ignored. JRebel imposes a performance overhead on the application and should not be used in production or performance tests. It is meant to be a development tool only.
            </p>
            <p>To use JRebel in your sbt project add the following options to java in sbt build file:
            </p>
        <pre><code class="no-highlight">
            -noverify -javaagent:/path/to/jrebel/jrebel.jar
        </code></pre>

            <h5>Automatic reload using SBT</h5>
            <div>
                SBT will allow you to signal a task to perform when file change, for example to restart the application when it detects code changes. The files and directories monitored can be configured - for example to if you are using JRebel you might to change the monitored content.<br />
                More about triggers on wiki: <a href="https://github.com/harrah/xsbt/wiki/Triggered-Execution">sbt wiki</a>. On old sbt wiki you can find some examples for <a href="http://code.google.com/p/simple-build-tool/wiki/WebApplications">web applications</a>, eg:
        <pre><code class="no-highlight">
            > jetty-run
            > ~ prepare-webapp
        </code></pre>
                <code>jetty-run</code> starts Jetty and monitors the directories given by scanDirectories and redeploys on changes. By default, the entire temporary web application directory is monitored. You might want to change scanDirectories in some cases. For example, set scanDirectories to Nil if you do not want to redeploy on any changes<br />
                <code>~ prepare-webapp</code> recompiles and recreates the web application whenever sources files change
            </div>
        </div>
    </div>

    <h2>Tutorials</h2>
    <div>
        <ul>
            <li><a href="http://docs.scala-lang.org/">Scala docs site</a></li>
            <li><a href="http://twitter.github.com/scala_school/index.html">twitter Scala school</a></li>
            <li><a href="http://www.slideshare.net/mariogleichmann/functional-scala-ii-in-practice">nice presentation</a></li>
        </ul>
    </div>

    <h2>Blogs</h2>
    <div>
        <ul>
            <li><a href="http://docs.scala-lang.org/">A++ [Eric Torreborre's Blog]</a></li>
            <li><a href="http://debasishg.blogspot.com">Ruminations of a Programmer</a></li>
        </ul>
    </div>

    <h2>Scala links</h2>
    <ul>
        <li><a href="http://docs.scala-lang.org/sips">SIP: Scala Improvement Process</a></li>
        <li><a href="http://nescala.org/2011/">nescala.org</a></li>
        <li><a href="http://marakana.com/s/videos_nescala_symposium,1092/index.html">2012 Northeast Scala Symposium Videos</a></li>
    </ul>

    <h2>other nice links</h2>
    <ul>
        <li><a href="http://www.willamette.edu/~fruehr/haskell/evolution.html">evolution of haskell programmer</a></li>

    </ul>

</div>


<!--
<br /><br />
<br /><br />

<h2>TODO</h2>
  doczytać o manifest tutaj:
  <ul>
    <li><a href="http://stackoverflow.com/questions/7732100/can-we-infer-generic-output-type">manifest</a></li>
    <li><a href="http://stackoverflow.com/questions/3587286/how-does-scalas-2-8-manifest-work">manifest2</a></li>
    <li><a href="http://stackoverflow.com/questions/5541154/context-bounds-shortcut-with-higher-kinded-types">manifest3</a></li>
    <li><a href="http://michid.wordpress.com/2008/04/18/meta-programming-with-scala-part-i-addition/">meta programming in Scala</a></li>
    <li><a href="http://jim-mcbeath.blogspot.com/2011/03/java-nio-and-scala-continuations.html?amp">java nio and Scala continuations</a></li>
    <li><br /></li>
    <li>Inne ciekawe;</li>
    <li><a href="http://stackoverflow.com/questions/2887655/making-stand-alone-jar-with-simple-build-tool">http://stackoverflow.com/questions/2887655/making-stand-alone-jar-with-simple-build-tool</a></li>
    <li><a href="http://michid.wordpress.com/2008/04/18/meta-programming-with-scala-part-i-addition/">meta programming in Scala</a></li>
    <li><a href="http://stackoverflow.com/questions/8243680/weird-nested-structural-type-in-gnerics">weird nested structural data</a></li>
    <li><a href="http://stackoverflow.com/questions/2603003/operator-in-scala">operator &lt;:&lt;</a></li>
    <li><a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">type level programming in Scala</a></li>
    <li><a href="http://www.informit.com/store/product.aspx?isbn=0321774094">Scala for the Impatient  - BOOK</a></li>
  </ul>




	<br />
	Funkcja toStream na List/Iterator <br />
	strona 547
-->



<script type="text/javascript" >
    hljs.tabReplace = '  '; // 2 spaces
    // ... or hljs.tabReplace = '<span class="indent">\t</span>';
    hljs.initHighlightingOnLoad();

</script>


</body>
</html>